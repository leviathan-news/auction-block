{
  "language": "Vyper",
  "sources": {
    "contracts/imports/ownable_2step.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Ownable 2-step\n@license MIT\n@author yearn.finance, asymmetry.finance\n@notice ownable_2step.vy is a two-step ownable contract that allows for a two-step transfer of ownership\n\"\"\"\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent PendingOwnershipTransfer:\n    old_owner: address\n    new_owner: address\n\n\nevent OwnershipTransferred:\n    old_owner: address\n    new_owner: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\nowner: public(address)\npending_owner: public(address)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice Initializes the contract setting the deployer as the initial owner\n    \"\"\"\n    self.owner = msg.sender\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Starts the ownership transfer of the contract\n         to a new account `new_owner`\n    @notice Note that this function can only be\n            called by the current `owner`. Also, there is\n            no security risk in setting `new_owner` to the\n            zero address as the default value of `pending_owner`\n            is in fact already the zero address and the zero\n            address cannot call `accept_ownership`. Eventually,\n            the function replaces the pending transfer if\n            there is one\n    @param new_owner The address of the new owner\n    \"\"\"\n    self._check_owner()\n    self.pending_owner = new_owner\n    log PendingOwnershipTransfer(self.owner, new_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @dev The new owner accepts the ownership transfer.\n    @notice Note that this function can only be\n            called by the current `pending_owner`\n    \"\"\"\n    assert self.pending_owner == msg.sender, \"!new owner\"\n    self._transfer_ownership(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner\n    \"\"\"\n    assert msg.sender == self.owner, \"!owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner` and deletes\n         any pending owner\n    @notice This is an `internal` function without\n            access restriction\n    @param new_owner The address of the new owner\n    \"\"\"\n    self.pending_owner = empty(address)\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n",
      "sha256sum": "65febf30a2b8904113177dda55aac703ed6df29a612e4a503d756c76ab678869"
    },
    "contracts/imports/pausable.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Pausable\n@license MIT\n@author Leviathan\n@notice pauseable.vy allows to implement an emergency stop mechanism that can be triggered by an authorized account\n\"\"\"\n\nimport ownable_2step as ownable\n\n\n# ============================================================================================\n# Modules\n# ============================================================================================\n\n\nuses: ownable\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent Paused:\n    account: address\n\n\nevent Unpaused:\n    account: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\npaused: public(bool)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice At initialisation time, the `owner` role will\n            be assigned to the `msg.sender` since we `uses`\n            the `ownable` module, which implements the\n            aforementioned logic at contract creation time.\n    \"\"\"\n    pass\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef pause():\n    \"\"\"\n    @dev Pauses the contract\n    \"\"\"\n    ownable._check_owner()\n    self._check_unpaused()\n    self.paused = True\n    log Paused(msg.sender)\n\n\n@external\ndef unpause():\n    \"\"\"\n    @dev Unpauses the contract\n    \"\"\"\n    ownable._check_owner()\n    self._check_paused()\n    self.paused = False\n    log Unpaused(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_unpaused():\n    \"\"\"\n    @dev Checks if the contract is unpaused\n    \"\"\"\n    assert not self.paused, \"paused\"\n\n\n@internal\ndef _check_paused():\n    \"\"\"\n    @dev Checks if the contract is paused\n    \"\"\"\n    assert self.paused, \"!paused\"\n",
      "sha256sum": "5a62cf2f1a9c567df539c5488b510362dc6ea62b9b0b1ca2c4d894c26e54de8f"
    },
    "contracts/AuctionDirectory.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Auction Directory\n@author Leviathan News\n@license MIT\n@notice Central registry and interface for Leviathan auction system\n@dev Core contract providing:\n     - Unified bidding interface for all auction types\n     - Multi-token support through zap contracts\n     - Permission management for delegated bidding\n     - Registry of all deployed auction contracts\n\"\"\"\n\n\n# ============================================================================================\n# \u2699\ufe0f Modules\n# ============================================================================================\n\n\nfrom ethereum.ercs import IERC20\n\nfrom .imports import ownable_2step as ownable\nfrom .imports import pausable\n\n\n# ============================================================================================\n# \ud83e\udde9 Interfaces\n# ============================================================================================\n\ninterface AuctionContract:\n    def current_auctions() -> DynArray[uint256, MAX_AUCTIONS]: view\n    def create_bid(\n        auction_id: uint256,\n        bid_amount: uint256,\n        ipfs_hash: String[46],\n        on_behalf_of: address,\n    ): nonpayable\n    def minimum_total_bid(auction_id: uint256) -> uint256: view\n    def minimum_additional_bid_for_user(\n        auction_id: uint256, user: address\n    ) -> uint256: view\n    def auction_bid_by_user(auction_id: uint256, user: address) -> uint256: view\n    def update_bid_metadata(\n        auction_id: uint256, ipfs_hash: String[46], on_behalf_of: address\n    ): nonpayable\n    def withdraw(\n        auction_id: uint256, on_behalf_of: address\n    ) -> uint256: nonpayable\n    def withdraw_multiple(\n        auction_ids: DynArray[uint256, 100], on_behalf_of: address\n    ): nonpayable\n\n\ninterface AuctionZap:\n    def get_dy(dx: uint256) -> uint256: view\n    def safe_get_dx(dy: uint256) -> uint256: view\n    def zap(token_amount: uint256, min_dy: uint256) -> uint256: nonpayable\n\n\ninterface AuctionOracle:\n    def price_usd() -> uint256: view\n\n\ninterface NFT:\n    def safe_mint(\n        owner: address, contract_address: address, auction_id: uint256\n    ) -> int256: nonpayable\n\n\n# ============================================================================================\n# \u2699\ufe0f Modules\n# ============================================================================================\n\ninitializes: ownable\nexports: (\n    ownable.owner,\n    ownable.pending_owner,\n    ownable.transfer_ownership,\n    ownable.accept_ownership,\n)\n\ninitializes: pausable[ownable := ownable]\nexports: (\n    pausable.paused,\n    pausable.pause,\n    pausable.unpause,\n)\n\n\n# ============================================================================================\n# \ud83c\udfe2 Structs\n# ============================================================================================\n\nstruct AuctionInfo:\n    contract_address: address\n    auction_id: uint256\n\n\nflag ApprovalStatus:\n    Nothing  # Default value, indicating no approval\n    BidOnly  # Approved for bid only\n    WithdrawOnly  # Approved for withdraw only\n    BidAndWithdraw  # Approved for both bid and withdraw\n\n\n# ============================================================================================\n# \ud83d\udce3 Events\n# ============================================================================================\n\nevent AuctionContractAdded:\n    contract_address: indexed(address)\n\n\nevent DirectoryDeprecated:\n    new_address: indexed(address)\n\n\nevent TokenSupportAdded:\n    token: indexed(address)\n    trader: indexed(address)\n\n\nevent TokenSupportRemoved:\n    token: indexed(address)\n\n\nevent ApprovedCallerSet:\n    account: address\n    caller: address\n    status: ApprovalStatus\n\n\n# ============================================================================================\n# \ud83d\udcdc Constants\n# ============================================================================================\n\nMAX_TOKENS: constant(uint256) = 100\nMAX_AUCTION_CONTRACTS: constant(uint256) = 1000\nMAX_AUCTIONS: constant(uint256) = 10000\nMAX_WITHDRAWALS: constant(uint256) = 100\n\n\n# ============================================================================================\n# \ud83d\udcbe Storage\n# ============================================================================================\n\n# Is there a more recent version of this diretory?\nis_current: public(bool)\nupgrade_address: public(address)\n\n# Auction Contracts\nregistered_contracts: public(DynArray[AuctionContract, MAX_AUCTION_CONTRACTS])\n\n# User settings: user -> caller -> status\napproved_caller: public(HashMap[address, HashMap[address, ApprovalStatus]])\n\n# Payment tokens\npayment_token: public(IERC20)\nsupported_tokens: public(DynArray[IERC20, MAX_TOKENS])\nadditional_tokens: public(HashMap[IERC20, AuctionZap])\noracle: public(AuctionOracle)\n\nnft: public(NFT)\n\n\n# ============================================================================================\n# \ud83d\udea7 Constructor\n# ============================================================================================\n\n@deploy\ndef __init__(payment_token: IERC20):\n    self.is_current = True\n    ownable.__init__()\n    pausable.__init__()\n    self.payment_token = payment_token\n\n\n# ============================================================================================\n# \ud83d\udc40 View functions\n# ============================================================================================\n@external\n@view\ndef active_auctions() -> DynArray[AuctionInfo, MAX_AUCTIONS]:\n    \"\"\"\n    @notice Returns all currently active auctions across all registered contracts\n    @dev Iterates through all registered contracts and their current auctions\n         Memory bounded by MAX_AUCTIONS constant\n    @return Array of AuctionInfo structs containing contract addresses and auction IDs\n    \"\"\"\n    auction_list: DynArray[AuctionInfo, MAX_AUCTIONS] = []\n\n    for _contract: AuctionContract in self.registered_contracts:\n        _current_auctions: DynArray[\n            uint256, MAX_AUCTIONS\n        ] = staticcall _contract.current_auctions()\n\n        for _auction_id: uint256 in _current_auctions:\n            auction_list.append(\n                AuctionInfo(\n                    contract_address=_contract.address, auction_id=_auction_id\n                )\n            )\n    return auction_list\n\n\n@external\n@view\ndef safe_get_dx(token: IERC20, dy: uint256) -> uint256:\n    \"\"\"\n    @notice Calculates the required input amount of alternate token for a desired bid\n    @dev Uses zap contract's safe calculation which includes safety margin\n         Reverts if token not supported\n    @param token The alternate token address to calculate for\n    @param dy The desired output amount in payment tokens\n    @return Required input amount of alternate token, including safety margin\n    \"\"\"\n\n    assert self.additional_tokens[token] != empty(AuctionZap), \"!token\"\n    return staticcall self.additional_tokens[token].safe_get_dx(dy)\n\n\n@external\n@view\ndef get_dy(token: IERC20, dx: uint256) -> uint256:\n    \"\"\"\n    @notice Calculates expected output of payment tokens for a given alternate token input\n    @dev Direct price quote without safety margin, use safe_get_dx for actual bidding\n    @param token The alternate token address to calculate for\n    @param dx The input amount of alternate token\n    @return Expected output amount in payment tokens\n    \"\"\"\n    assert self.additional_tokens[token] != empty(AuctionZap), \"!token\"\n    return staticcall self.additional_tokens[token].get_dy(dx)\n\n\n@external\n@view\ndef num_auction_contracts() -> uint256:\n    \"\"\"\n    @notice Returns the total number of registered auction contracts\n    @dev Helper function for UI pagination/iteration\n    @return Current count of registered auction contracts\n    \"\"\"\n    return len(self.registered_contracts)\n\n\n@external\n@view\ndef num_supported_tokens() -> uint256:\n    \"\"\"\n    @notice Returns the total number of registered token zaps\n    @dev Helper function for UI pagination/iteration\n    @return Current count of supported tokens\n    \"\"\"\n    return len(self.supported_tokens)\n\n\n@external\n@view\ndef payment_token_price_usd() -> uint256:\n    return staticcall self.oracle.price_usd()\n\n\n# ============================================================================================\n# \u270d\ufe0f Write functions\n# ============================================================================================\n\n\n@external\n@nonreentrant\ndef create_bid(\n    auction_contract: AuctionContract,\n    auction_id: uint256,\n    bid_amount: uint256,\n    ipfs_hash: String[46] = \"\",\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Place a bid on an auction using the primary payment token\n    @dev Transfers tokens from bidder to directory, then executes bid on auction contract\n         Caller must have approval status or be bidding for themselves\n    @param auction_contract The target auction contract address\n    @param auction_id The ID of the auction to bid on\n    @param bid_amount Total bid amount in payment tokens\n    @param ipfs_hash Optional IPFS hash for bid metadata\n    @param on_behalf_of Address to place bid for (defaults to caller)\n    @custom:security Requires auction contract to be registered and appropriate approval for delegated bids\n                     Requires appropriate approval status for delegated bids\n    \"\"\"\n    pausable._check_unpaused()\n    assert self._is_registered_contract(auction_contract), \"!contract\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.BidOnly)\n\n    # Get tokens from user\n    _current_bid: uint256 = staticcall auction_contract.auction_bid_by_user(\n        auction_id, on_behalf_of\n    )\n    _transfer_amount: uint256 = bid_amount\n    if _current_bid > 0:\n        _transfer_amount = bid_amount - _current_bid\n\n    extcall self.payment_token.transferFrom(\n        on_behalf_of, self, _transfer_amount\n    )\n    extcall self.payment_token.approve(\n        auction_contract.address, _transfer_amount\n    )\n    extcall auction_contract.create_bid(\n        auction_id, bid_amount, ipfs_hash, on_behalf_of\n    )\n\n\n@external\n@nonreentrant\ndef create_bid_with_token(\n    auction_contract: AuctionContract,\n    auction_id: uint256,\n    token_amount: uint256,\n    token: IERC20,\n    min_total_bid: uint256,\n    ipfs_hash: String[46] = \"\",\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Place a bid using an alternative token that gets swapped to the payment token\n    @dev Transfers alternate tokens from bidder, executes swap via zap contract, then places bid\n         Must approve both Directory for alternate token and auction for payment token\n    @param auction_contract The target auction contract\n    @param auction_id ID of the auction to bid on\n    @param token_amount Amount of alternate token to swap and bid with\n    @param token Address of the alternate token (must be supported)\n    @param min_total_bid Minimum acceptable total bid after token conversion\n    @param ipfs_hash Optional IPFS hash for bid metadata\n    @param on_behalf_of Address to place bid for (defaults to caller)\n    @custom:security Requires auction contract to be registered\n                     Requires token to have zap contract configured\n                     Requires appropriate approval status for delegated bids\n    \"\"\"\n    pausable._check_unpaused()\n    # Contract exists\n    assert self._is_registered_contract(auction_contract), \"!contract\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.BidOnly)\n\n    # Token trading authorized\n    auction_zap: AuctionZap = self.additional_tokens[token]\n    assert auction_zap != empty(AuctionZap), \"!token\"\n\n    # Did the user request enough tokens?\n    current_bid: uint256 = staticcall auction_contract.auction_bid_by_user(\n        auction_id, on_behalf_of\n    )\n\n    # Is the user's bid sufficient\n    min_requirement: uint256 = staticcall auction_contract.minimum_total_bid(\n        auction_id\n    )\n    assert min_total_bid >= min_requirement, \"!bid_amount\"\n\n    expected_swap_output: uint256 = staticcall auction_zap.get_dy(token_amount)\n    expected_total_bid: uint256 = current_bid + expected_swap_output\n    assert expected_total_bid >= min_total_bid, \"!token_amount\"\n\n    # Get tokens from user and zap\n    extcall token.transferFrom(on_behalf_of, self, token_amount)\n    extcall token.approve(auction_zap.address, token_amount)\n    received: uint256 = extcall auction_zap.zap(\n        token_amount, expected_swap_output\n    )\n\n    # Place bid with received tokens\n    extcall self.payment_token.approve(auction_contract.address, received)\n\n    extcall auction_contract.create_bid(\n        auction_id, received + current_bid, ipfs_hash, on_behalf_of\n    )\n\n\n@external\ndef set_approved_caller(caller: address, status: ApprovalStatus):\n    \"\"\"\n    @notice Configure delegation permissions for a specific caller\n    @dev Allows user to set granular permissions for another address\n    @param caller Address being granted or restricted permissions\n    @param status Approval level for the caller:\n                  - Nothing: No permissions\n                  - BidOnly: Can place bids on behalf of user\n                  - WithdrawOnly: Can withdraw funds on behalf of user\n                  - BidAndWithdraw: Full bidding and withdrawal permissions\n    \"\"\"\n    self.approved_caller[msg.sender][caller] = status\n    log ApprovedCallerSet(msg.sender, caller, status)\n\n\n@external\ndef mint_nft(\n    target: address, auction_id: uint256, contract_addr: address = msg.sender\n) -> int256:\n    \"\"\"\n    @notice Mint NFT or fail gracefully\n    @param target Address to mint the NFT to\n    @param auction_id Auction ID that won the NFT\n    @return -1 on fail or NFT id\n    \"\"\"\n    token_id: int256 = -1\n    if self._is_registered_contract(\n        AuctionContract(contract_addr)\n    ) and self.nft.address != empty(address):\n        token_id = extcall self.nft.safe_mint(target, contract_addr, auction_id)\n    return token_id\n\n\n@external\n@nonreentrant\ndef update_bid_metadata(\n    auction_contract: AuctionContract,\n    auction_id: uint256,\n    ipfs_hash: String[46],\n    on_behalf_of: address,\n):\n    \"\"\"\n    @notice Update IPFS metadata associated with a user's bid\n    @dev Allows adding or updating metadata for any bid by user\n         Does not affect bid status or amount\n    @param auction_contract The target auction contract address\n    @param auction_id The auction to update metadata for\n    @param ipfs_hash New IPFS hash to associate with bid\n    @param on_behalf_of Address to update metadata for (defaults to caller)\n    @custom:security Requires bid permission for on_behalf_of\n    \"\"\"\n    assert self._is_registered_contract(auction_contract), \"!contract\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.BidOnly)\n    extcall auction_contract.update_bid_metadata(\n        auction_id, ipfs_hash, on_behalf_of\n    )\n\n\n@external\n@nonreentrant\ndef withdraw(\n    auction_contract: AuctionContract,\n    auction_id: uint256,\n    on_behalf_of: address = msg.sender,\n) -> uint256:\n    \"\"\"\n    @notice Withdraw pending returns from previous outbid\n    @dev Only available after auction is settled\n         Clears pending returns for auction/user combination\n    @param auction_contract The target auction contract address\n    @param auction_id Auction to withdraw from\n    @param on_behalf_of Address to withdraw for (defaults to caller)\n    @return Amount of tokens withdrawn\n    @custom:security Requires withdraw permission for on_behalf_of\n                     Only withdraws if auction is settled\n    \"\"\"\n    pausable._check_unpaused()\n    assert self._is_registered_contract(auction_contract), \"!contract\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.WithdrawOnly)\n    return extcall auction_contract.withdraw(auction_id, on_behalf_of)\n\n\n@external\n@nonreentrant\ndef withdraw_multiple(\n    auction_contract: AuctionContract,\n    auction_ids: DynArray[uint256, MAX_WITHDRAWALS],\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Batch withdraw pending returns from multiple auctions\n    @dev Only withdraws from settled auctions\n         Skips live auctions and non-settled auctions\n    @param auction_ids Array of auction IDs to withdraw from\n    @param on_behalf_of Address to withdraw for (defaults to caller)\n    @custom:security Requires withdraw permission for on_behalf_of\n                     Only processes settled auctions\n                     Limited to MAX_WITHDRAWALS auctions\n    \"\"\"\n    pausable._check_unpaused()\n    assert self._is_registered_contract(auction_contract), \"!contract\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.WithdrawOnly)\n    extcall auction_contract.withdraw_multiple(auction_ids, on_behalf_of)\n\n\n# ============================================================================================\n# \ud83d\udc51 Owner functions\n# ============================================================================================\n\n\n@external\ndef register_auction_contract(new_contract: AuctionContract):\n    \"\"\"\n    @notice Registers a new auction contract implementation\n    @dev Only callable by owner\n         New contract must implement AuctionContract interface\n    @param new_contract Address of auction contract to register\n    @custom:security Ensure contract is fully configured before registering\n    \"\"\"\n    self.registered_contracts.append(new_contract)\n    log AuctionContractAdded(new_contract.address)\n\n\n@external\ndef deprecate_directory(new_address: address):\n    \"\"\"\n    @notice Marks this directory as deprecated in favor of new implementation\n    @dev Only callable by owner\n         Sets is_current to False and stores upgrade address\n    @param new_address Address of new directory implementation\n    @custom:security Users should migrate to new directory after deprecation\n    \"\"\"\n    ownable._check_owner()\n    self.is_current = False\n    self.upgrade_address = new_address\n    log DirectoryDeprecated(new_address)\n\n\n@external\ndef set_nft(nft_addr: address):\n    \"\"\"\n    @notice Updates the NFT contract\n    @dev Set to zero address to disable NFT minting\n    @param nft_addr Address of NFT contract\n    \"\"\"\n    ownable._check_owner()\n    self.nft = NFT(nft_addr)\n\n\n@external\ndef add_token_support(token: IERC20, zap_address: AuctionZap):\n    \"\"\"\n    @notice Adds support for a new alternate payment token\n    @dev Only callable by owner\n         Configures token with corresponding zap contract for AMM integration\n    @param token Address of alternate token to support\n    @param zap_address Address of zap contract that handles token conversion\n    @custom:security Zap contract must be verified and tested before adding\n                     Cannot add primary payment token as alternate token\n    \"\"\"\n\n    ownable._check_owner()\n    assert token.address != empty(address), \"!token\"\n    assert zap_address.address != empty(address), \"!trader\"\n    assert token != self.payment_token, \"!payment_token\"\n\n    self.additional_tokens[token] = zap_address\n    self.supported_tokens.append(token)\n    log TokenSupportAdded(token.address, zap_address.address)\n\n\n@external\ndef revoke_token_support(token_addr: IERC20):\n    \"\"\"\n    @notice Remove support for an alternative payment token\n    @dev Only owner\n    @param token_addr Address of previously supported token to remove\n    \"\"\"\n    ownable._check_owner()\n    assert token_addr.address != empty(address), \"!token\"\n    assert self.additional_tokens[token_addr] != empty(AuctionZap), \"!supported\"\n    self.additional_tokens[token_addr] = empty(AuctionZap)\n\n    # Remove the token from supported_tokens\n    for i: uint256 in range(MAX_TOKENS):\n        if i >= len(self.supported_tokens):\n            break\n\n        if self.supported_tokens[i] == token_addr:\n            # Swap with the last element and pop\n            self.supported_tokens[i] = self.supported_tokens[\n                len(self.supported_tokens) - 1\n            ]\n            self.supported_tokens.pop()\n            break\n    log TokenSupportRemoved(token_addr.address)\n\n\n@external\ndef set_payment_token_oracle(new_oracle: AuctionOracle):\n    ownable._check_owner()\n    self.oracle = new_oracle\n\n\n# ============================================================================================\n# \ud83c\udfe0 Internal functions\n# ============================================================================================\n\n@internal\n@view\ndef _check_caller(\n    _account: address, _caller: address, _req_status: ApprovalStatus\n):\n    if _account != _caller:\n        _status: ApprovalStatus = self.approved_caller[_account][_caller]\n        if _status == ApprovalStatus.BidAndWithdraw:\n            return\n        assert (_status == _req_status), \"!caller\"\n\n\n@internal\n@view\ndef _is_registered_contract(contract_to_check: AuctionContract) -> bool:\n    _found_contract: bool = False\n    for _contract: AuctionContract in self.registered_contracts:\n        if contract_to_check == _contract:\n            _found_contract = True\n    return _found_contract\n",
      "sha256sum": "de842738f114d29d88780fb9ff277b9d2c995174bc93497a8d5a2ee31db72444"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/AuctionDirectory.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "76256b4780e49b5d657ebc7bf7b7efe7a2325f457d7ec151bad58e9ad5e3c56e"
}