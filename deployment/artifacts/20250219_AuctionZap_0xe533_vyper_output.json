{
  "language": "Vyper",
  "sources": {
    "contracts/imports/ownable_2step.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Ownable 2-step\n@license MIT\n@author yearn.finance, asymmetry.finance\n@notice ownable_2step.vy is a two-step ownable contract that allows for a two-step transfer of ownership\n\"\"\"\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent PendingOwnershipTransfer:\n    old_owner: address\n    new_owner: address\n\n\nevent OwnershipTransferred:\n    old_owner: address\n    new_owner: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\nowner: public(address)\npending_owner: public(address)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice Initializes the contract setting the deployer as the initial owner\n    \"\"\"\n    self.owner = msg.sender\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Starts the ownership transfer of the contract\n         to a new account `new_owner`\n    @notice Note that this function can only be\n            called by the current `owner`. Also, there is\n            no security risk in setting `new_owner` to the\n            zero address as the default value of `pending_owner`\n            is in fact already the zero address and the zero\n            address cannot call `accept_ownership`. Eventually,\n            the function replaces the pending transfer if\n            there is one\n    @param new_owner The address of the new owner\n    \"\"\"\n    self._check_owner()\n    self.pending_owner = new_owner\n    log PendingOwnershipTransfer(self.owner, new_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @dev The new owner accepts the ownership transfer.\n    @notice Note that this function can only be\n            called by the current `pending_owner`\n    \"\"\"\n    assert self.pending_owner == msg.sender, \"!new owner\"\n    self._transfer_ownership(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner\n    \"\"\"\n    assert msg.sender == self.owner, \"!owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner` and deletes\n         any pending owner\n    @notice This is an `internal` function without\n            access restriction\n    @param new_owner The address of the new owner\n    \"\"\"\n    self.pending_owner = empty(address)\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n",
      "sha256sum": "65febf30a2b8904113177dda55aac703ed6df29a612e4a503d756c76ab678869"
    },
    "contracts/AuctionZap.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title WETH Auction Zap\n@author Leviathan\n@license MIT\n@notice Facilitates token swaps and bidding for Leviathan auction system\n@dev Provides core functionality for:\n     - Token conversion through Curve pool\n     - Direct bidding with alternative tokens\n     - Flexible trading across different token pairs\n     - Delegated bidding permissions\n\"\"\"\n\n# ============================================================================================\n# \u2699\ufe0f Modules\n# ============================================================================================\n\nfrom ethereum.ercs import IERC20\n\nfrom .imports import ownable_2step as ownable\n\ninitializes: ownable\n\n# ============================================================================================\n# \ud83e\udde9 Interfaces\n# ============================================================================================\n\ninterface Pool:\n    def get_dy(i: uint256, j: uint256, dx: uint256) -> uint256: view\n    def get_dx(i: uint256, j: uint256, dy: uint256) -> uint256: view\n    def exchange(\n        i: uint256,\n        j: uint256,\n        dx: uint256,\n        min_dy: uint256,\n    ) -> uint256: nonpayable\n\n\ninterface AuctionBlock:\n    def auction_bid_by_user(auction_id: uint256, user: address) -> uint256: view\n    def create_bid(\n        auction_id: uint256,\n        bid_amount: uint256,\n        ipfs_hash: String[46],\n        on_behalf_of: address,\n    ): nonpayable\n    def minimum_additional_bid_for_user(\n        auction_id: uint256, user: address\n    ) -> uint256: view\n\n\nflag ApprovalStatus:\n    Nothing  # Default value, indicating no approval\n    BidOnly  # Approved for bid only\n    WithdrawOnly  # Approved for withdraw only\n    BidAndWithdraw  # Approved for both bid and withdraw\n\n\n# ============================================================================================\n# \ud83d\udce3 Events\n# ============================================================================================\n\nevent ApprovedCallerSet:\n    account: address\n    caller: address\n    status: ApprovalStatus\n\n\nevent DirectorySet:\n    directory_address: address\n\n\n# ============================================================================================\n# \ud83d\udcbe Storage\n# ============================================================================================\n\n\npayment_token: public(IERC20)\ntrading_token: public(IERC20)\npool: public(Pool)\nindices: public(uint256[2])\n\n# User settings: user -> caller -> status\napproved_caller: public(HashMap[address, HashMap[address, ApprovalStatus]])\nauthorized_directory: public(address)\n\n# ============================================================================================\n# \ud83d\udea7 Constructor\n# ============================================================================================\n\n\n@deploy\ndef __init__(\n    _payment_token: IERC20,\n    _trading_token: IERC20,\n    _pool: Pool,\n    _indices: uint256[2],\n):\n    self.payment_token = _payment_token\n    self.trading_token = _trading_token\n    self.pool = _pool\n    self.indices = _indices\n\n    ownable.__init__()\n\n\n# ============================================================================================\n# \ud83d\udc40 View functions\n# ============================================================================================\n\n@external\n@view\ndef get_dx(_dy: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate input token amount required for desired output\n    @param _dy Desired output token amount\n    @return Required input token amount\n    \"\"\"\n\n    return self._get_dx(_dy)\n\n\n@external\n@view\ndef get_dy(_dx: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate output token amount for given input\n    @param _dx Input token amount\n    @return Expected output token amount\n    \"\"\"\n\n    return self._get_dy(_dx)\n\n\n@external\n@view\ndef safe_get_dx(_dy: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate input amount with extra buffer to guarantee output\n    @dev Iterative calculation to ensure sufficient input for desired output\n         Gas intensive so only for offchain use\n    @param _dy Desired output token amount\n    @return Input token amount with safety margin\n    \"\"\"\n\n    _actual_dy: uint256 = 0\n    _dx: uint256 = self._get_dx(_dy)\n    for _i: uint256 in range(10):\n        _actual_dy = self._get_dy(_dx)\n        if _actual_dy >= _dy:\n            break\n        else:\n            _dx = _dx * 100000001 // 100000000\n    assert _actual_dy >= _dy\n    return _dx\n\n\n# ============================================================================================\n# \u270d\ufe0f Write functions\n# ============================================================================================\n\n\n@external\ndef zap(token_amount: uint256, min_dy: uint256) -> uint256:\n    \"\"\"\n    @notice Trade misc token for payment token\n    @dev Utilized in Auction directory\n    @param token_amount Input amount of trading token (WETH) to trade\n    @param min_dy Minimum payment tokens to receive\n    @return Amount of payment tokens received\n    \"\"\"\n    amount_received: uint256 = self._exchange(token_amount, min_dy, msg.sender)\n    extcall self.payment_token.transfer(msg.sender, amount_received)\n    return amount_received\n\n\n@external\ndef zap_and_bid(\n    auction_contract: AuctionBlock,\n    auction_id: uint256,\n    token_amount: uint256,\n    min_total_bid: uint256,\n    ipfs_hash: String[46] = \"\",\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Swap tokens and place bid in single transaction\n    @dev Converts trading token to payment token and bids on auction\n         Requires trading token approval on Zap\n         Requires payment token approval on AuctionHouse\n         Requires setting this contract as approved caller for bidding on AuctionHouse\n    @param auction_contract Target auction contract\n    @param auction_id Specific auction to bid on\n    @param token_amount Trading tokens to convert\n    @param min_total_bid Minimum acceptable total bid after conversion\n    @param ipfs_hash Optional metadata for bid\n    @param on_behalf_of Address to bid for\n    \"\"\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.BidOnly)\n    current_bid: uint256 = staticcall auction_contract.auction_bid_by_user(\n        auction_id, on_behalf_of\n    )\n    tokens_needed: uint256 = (\n        staticcall auction_contract.minimum_additional_bid_for_user(\n            auction_id, on_behalf_of\n        )\n    )\n\n    dy: uint256 = self._get_dy(token_amount)\n    assert dy >= tokens_needed, \"!token_amount\"\n    assert dy + current_bid >= min_total_bid, \"!token_amount\"\n\n    token_source: address = on_behalf_of\n    if msg.sender == self.authorized_directory:\n        token_source = self.authorized_directory\n\n    amount_received: uint256 = self._exchange(token_amount, dy, token_source)\n\n    total_bid: uint256 = amount_received + current_bid\n    assert total_bid >= min_total_bid, \"!token_amount\"\n\n    extcall self.payment_token.transfer(msg.sender, amount_received)\n    extcall auction_contract.create_bid(\n        auction_id, total_bid, ipfs_hash, on_behalf_of\n    )\n\n\n@external\ndef exchange(\n    _dx: uint256, _min_dy: uint256, _from: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Direct WETH -> SQUID trade through Curve pool\n    @param _dx Input amount of trading token (WETH) to exchange\n    @param _min_dy Minimum amount of payment token to receive\n    @param _from Optional address to pull tokens from\n    @return Amount of payment token received\n    \"\"\"\n    received: uint256 = self._exchange(_dx, _min_dy, _from)\n    # Transfer output tokens back to sender\n    extcall self.payment_token.transfer(_from, received)\n    return received\n\n\n@external\ndef set_approved_caller(caller: address, status: ApprovalStatus):\n    \"\"\"\n    @notice Configure delegation permissions for a specific caller\n    @dev Allows user to set granular permissions for another address\n    @param caller Address being granted or restricted permissions\n    @param status Approval level for the caller:\n                  - Nothing: No permissions\n                  - BidOnly: Can place bids on behalf of user\n                  - WithdrawOnly: Can withdraw funds on behalf of user\n                  - BidAndWithdraw: Full bidding and withdrawal permissions\n    \"\"\"\n    self.approved_caller[msg.sender][caller] = status\n    log ApprovedCallerSet(msg.sender, caller, status)\n\n\n# ============================================================================================\n# \ud83d\udc51 Owner functions\n# ============================================================================================\n\n\n@external\ndef set_approved_directory(directory_address: address):\n    \"\"\"\n    @notice Set authorized directory contract address\n    @dev Only callable by owner\n         Directory contract gets special permissions for bidding\n    @param directory_address Address of directory contract\n    @custom:security Directory can bypass normal approval checks\n                     Only one directory can be authorized at a time\n    \"\"\"\n    ownable._check_owner()\n    self.authorized_directory = directory_address\n    log DirectorySet(directory_address)\n\n\n# ============================================================================================\n# \ud83c\udfe0 Internal functions\n# ============================================================================================\n\n@internal\ndef _exchange(\n    _dx: uint256, _min_dy: uint256, _from: address = msg.sender\n) -> uint256:\n    # Transfer tokens from sender to this contract\n    extcall self.trading_token.transferFrom(_from, self, _dx)\n\n    # Do the exchange\n    extcall self.trading_token.approve(self.pool.address, max_value(uint256))\n    received: uint256 = extcall self.pool.exchange(\n        self.indices[0], self.indices[1], _dx, _min_dy\n    )\n    return received\n\n\n@internal\n@view\ndef _get_dx(_dy: uint256) -> uint256:\n    return staticcall self.pool.get_dx(self.indices[0], self.indices[1], _dy)\n\n\n@internal\n@view\ndef _get_dy(_dx: uint256) -> uint256:\n    return staticcall self.pool.get_dy(self.indices[0], self.indices[1], _dx)\n\n\n@internal\n@view\ndef _check_caller(\n    _account: address, _caller: address, _req_status: ApprovalStatus\n):\n    # Directory contract assumes onus of confirming status\n    if _account != _caller and msg.sender != self.authorized_directory:\n        _status: ApprovalStatus = self.approved_caller[_account][_caller]\n        if _status == ApprovalStatus.BidAndWithdraw:\n            return\n        assert (_status == _req_status), \"!caller\"\n",
      "sha256sum": "3d3b6ca130cd05234cce416cddda5dc1ccd1fb6d63df106fa73ae925b12052df"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/AuctionZap.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "3240a59e0c5330936d3f203de594f6af54f309e27e31fd18da44e373a38d003e"
}