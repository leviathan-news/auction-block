{
  "language": "Vyper",
  "sources": {
    "contracts/interfaces/IERC721Metadata.vyi": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-721 Optional Metadata Interface Definition\n@custom:contract-name IERC721Metadata\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice The metadata extension is optional for an ERC-721\n        smart contract. This allows a smart contract to\n        be interrogated for its name and for details about\n        the asset(s) which a non-fungible token (NFT)\n        represents. For more details, please refer to:\n        https://eips.ethereum.org/EIPS/eip-721#specification.\n\n        Note that Vyper interfaces that implement functions\n        with return values that require an upper bound (e.g.\n        `Bytes`, `DynArray`, or `String`), the upper bound\n        defined in the interface represents the lower bound\n        of the implementation:\n        https://github.com/vyperlang/vyper/pull/3205.\n\n        On how to use interfaces in Vyper, please visit:\n        https://vyper.readthedocs.io/en/latest/interfaces.html#interfaces.\n\"\"\"\n\n\n# @dev We import and implement the `IERC165` interface,\n# which is a built-in interface of the Vyper compiler.\nfrom ethereum.ercs import IERC165\n\nimplements: IERC165\n\n\n# @dev We import the `IERC721` interface, which is a built-in\n# interface of the Vyper compiler, to highlight the association\n# of the custom `IERC721Metadata` interface with the built-in\n# `IERC721` interface.\n# @notice The interface `IERC721Metadata` must be used in conjunction\n# with the built-in interface `IERC721` to be EIP-721 compatible.\n# If you want to use this interface as a stand-alone interface,\n# you must add `implements: IERC721` to this interface and implement\n# all required events and functions accordingly.\nfrom ethereum.ercs import IERC721\n\n\n@external\n@view\ndef supportsInterface(interfaceId: bytes4) -> bool:\n    \"\"\"\n    @dev Returns `True` if this contract implements the\n         interface defined by `interfaceId`.\n    @notice For more details on how these identifiers are\n            created, please refer to:\n            https://eips.ethereum.org/EIPS/eip-165.\n    @param interfaceId The 4-byte interface identifier.\n    @return bool The verification whether the contract\n            implements the interface or not.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef name() -> String[25]:\n    \"\"\"\n    @dev Returns the token collection name.\n    @return String The maximum 25-character\n            user-readable string name of the\n            token collection.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef symbol() -> String[5]:\n    \"\"\"\n    @dev Returns the token collection symbol.\n    @return String The maximum 5-character\n            user-readable string symbol of the\n            token collection.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef tokenURI(_tokenId: uint256) -> String[512]:\n    \"\"\"\n    @dev Returns the Uniform Resource Identifier (URI)\n         for `_tokenId` token.\n    @notice Throws if `_tokenId` is not a valid ERC-721 token.\n    @param _tokenId The 32-byte identifier of the token.\n    @return String The maximum 512-character user-readable\n            string token URI of the `_tokenId` token.\n    \"\"\"\n    ...\n",
      "sha256sum": "13f11c3b16b27d451c477cd9323b829106716174c2c4d0d2b7f05a385c11cd88"
    },
    "contracts/interfaces/IERC721Enumerable.vyi": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-721 Optional Enumeration Interface Definition\n@custom:contract-name IERC721Enumerable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice The enumeration extension is optional for an ERC-721\n        smart contract. This allows a contract to publish its\n        full list of ERC-721 tokens and make them discoverable.\n        For more details, please refer to:\n        https://eips.ethereum.org/EIPS/eip-721#specification.\n\n        On how to use interfaces in Vyper, please visit:\n        https://vyper.readthedocs.io/en/latest/interfaces.html#interfaces.\n\"\"\"\n\n\n# @dev We import and implement the `IERC165` interface,\n# which is a built-in interface of the Vyper compiler.\nfrom ethereum.ercs import IERC165\n\nimplements: IERC165\n\n\n# @dev We import the `IERC721` interface, which is a built-in\n# interface of the Vyper compiler, to highlight the association\n# of the custom `IERC721Enumerable` interface with the built-in\n# `IERC721` interface.\n# @notice The interface `IERC721Enumerable` must be used in conjunction\n# with the built-in interface `IERC721` to be EIP-721 compatible.\n# If you want to use this interface as a stand-alone interface,\n# you must add `implements: IERC721` to this interface and implement\n# all required events and functions accordingly.\nfrom ethereum.ercs import IERC721\n\n\n@external\n@view\ndef supportsInterface(interfaceId: bytes4) -> bool:\n    \"\"\"\n    @dev Returns `True` if this contract implements the\n         interface defined by `interfaceId`.\n    @notice For more details on how these identifiers are\n            created, please refer to:\n            https://eips.ethereum.org/EIPS/eip-165.\n    @param interfaceId The 4-byte interface identifier.\n    @return bool The verification whether the contract\n            implements the interface or not.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef totalSupply() -> uint256:\n    \"\"\"\n    @dev Returns the amount of tokens in existence.\n    @return uint256 The 32-byte token supply.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef tokenByIndex(_index: uint256) -> uint256:\n    \"\"\"\n    @dev Returns a token ID at a given `_index` of\n         all the tokens stored by the contract.\n    @notice Use along with `totalSupply` to enumerate\n            all tokens.\n    @param _index The 32-byte counter (must be less\n           than `totalSupply()`).\n    @return uint256 The 32-byte token ID at index\n            `_index`.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef tokenOfOwnerByIndex(_owner: address, _index: uint256) -> uint256:\n    \"\"\"\n    @dev Returns a token ID owned by `_owner` at a\n         given `_index` of its token list.\n    @notice Use along with `balanceOf` to enumerate\n            all of `_owner`'s tokens.\n    @param _owner The 20-byte owner address.\n    @param _index The 32-byte counter (must be less\n           than `balanceOf(_owner)`).\n    @return uint256 The 32-byte token ID owned by\n            `_owner` at index `_index`.\n    \"\"\"\n    ...\n",
      "sha256sum": "4f53e5045dfc3e74efba76727a7c61ea7a7b36e1cb480745a44c9a97e864cc9c"
    },
    "contracts/interfaces/IERC721Permit.vyi": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-4494 Interface Definition\n@custom:contract-name IERC721Permit\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice The `permit` function implements approvals via\n        EIP-712 secp256k1 signatures for ERC-721 tokens:\n        https://eips.ethereum.org/EIPS/eip-4494. The\n        `permit` function allows users to modify the\n        permission of who can manage a `tokenId` using\n        a signed message (via secp256k1 signatures),\n        instead of through `msg.sender`. By not relying\n        on `approve`, the token holder's account does not\n        need to send a transaction and therefore does not\n        need to hold ether, enabling important use cases\n        such as meta-transactions.\n\n        IMPORTANT: Due to sake of consistency, we follow EIP-2612's\n        pattern (see https://eips.ethereum.org/EIPS/eip-2612) and\n        implement the `permit` function via the secp256k1 signature\n        parameters `v`, `r`, and `s` and do not support EIP-2098\n        signatures (64-byte length, see https://eips.ethereum.org/EIPS/eip-2098).\n        The ERC-165 identifier for this interface is `0x589C5CE2`.\n\n        On how to use interfaces in Vyper, please visit:\n        https://vyper.readthedocs.io/en/latest/interfaces.html#interfaces.\n\"\"\"\n\n\n# @dev We import and implement the `IERC165` interface,\n# which is a built-in interface of the Vyper compiler.\nfrom ethereum.ercs import IERC165\n\nimplements: IERC165\n\n\n@external\n@view\ndef supportsInterface(interfaceId: bytes4) -> bool:\n    \"\"\"\n    @dev Returns `True` if this contract implements the\n         interface defined by `interfaceId`.\n    @notice For more details on how these identifiers are\n            created, please refer to:\n            https://eips.ethereum.org/EIPS/eip-165.\n    @param interfaceId The 4-byte interface identifier.\n    @return bool The verification whether the contract\n            implements the interface or not.\n    \"\"\"\n    ...\n\n\n@external\ndef permit(\n    spender: address,\n    tokenId: uint256,\n    deadline: uint256,\n    v: uint8,\n    r: bytes32,\n    s: bytes32,\n):\n    \"\"\"\n    @dev Sets permission to `spender` to transfer `tokenId`\n         token to another account, given `owner`'s signed\n         approval.\n    @notice Note that `spender` cannot be the zero address.\n            Also, `deadline` must be a block timestamp in\n            the future. `v`, `r`, and `s` must be a valid\n            secp256k1 signature from `owner` over the\n            EIP-712-formatted function arguments. Eventually,\n            the signature must use `tokenId`'s current nonce.\n    @param spender The 20-byte spender address.\n    @param tokenId The 32-byte identifier of the token.\n    @param deadline The 32-byte block timestamp up\n           which the `spender` is allowed to spend `tokenId`.\n    @param v The secp256k1 1-byte signature parameter `v`.\n    @param r The secp256k1 32-byte signature parameter `r`.\n    @param s The secp256k1 32-byte signature parameter `s`.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef nonces(tokenId: uint256) -> uint256:\n    \"\"\"\n    @dev Returns the current on-chain tracked nonce of `tokenId`.\n    @param tokenId The 32-byte identifier of the token.\n    @return uint256 The 32-byte `tokenId` nonce.\n    \"\"\"\n    ...\n\n\n@external\n@view\ndef DOMAIN_SEPARATOR() -> bytes32:\n    \"\"\"\n    @dev Returns the domain separator for the current chain.\n    @return bytes32 The 32-byte domain separator.\n    \"\"\"\n    ...\n",
      "sha256sum": "9ce7232454ffce661bba4010d5bcaa1f63c13d1d96a67427640a73168477a7f3"
    },
    "contracts/interfaces/IERC4906.vyi": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-4906 Interface Definition\n@custom:contract-name IERC4906\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice The ERC-4906 standard is an extension of EIP-721.\n        It adds a `MetadataUpdate` event to EIP-721 tokens.\n        The ERC-165 identifier for this interface is `0x49064906`.\n        For more details, please refer to:\n        https://eips.ethereum.org/EIPS/eip-4906.\n\n        On how to use interfaces in Vyper, please visit:\n        https://vyper.readthedocs.io/en/latest/interfaces.html#interfaces.\n\"\"\"\n\n\n# @dev We import and implement the `IERC165` interface,\n# which is a built-in interface of the Vyper compiler.\nfrom ethereum.ercs import IERC165\n\nimplements: IERC165\n\n\n# @dev We import the `IERC721` interface, which is a built-in\n# interface of the Vyper compiler, to highlight the association\n# of the custom `IERC4906` interface with the built-in `IERC721`\n# interface.\n# @notice The interface `IERC4906` must be used in conjunction\n# with the built-in interface `IERC721` to be EIP-721 compatible.\n# If you want to use this interface as a stand-alone interface,\n# you must add `implements: IERC721` to this interface and implement\n# all required events and functions accordingly.\nfrom ethereum.ercs import IERC721\n\n\n# @dev Emitted when the metadata of a token is changed.\n# Thus, third-party platforms, such as NFT marketplaces,\n# can update the images and associated attributes of the\n# NFT in a timely manner.\nevent MetadataUpdate:\n    _tokenId: uint256\n\n\n# @dev Emitted when the metadata of a range of tokens is\n# changed. Thus, third-party platforms, such as NFT marketplaces,\n# can update the images and associated attributes of the\n# NFTs in a timely manner.\nevent BatchMetadataUpdate:\n    _fromTokenId: uint256\n    _toTokenId: uint256\n\n\n@external\n@view\ndef supportsInterface(interfaceId: bytes4) -> bool:\n    \"\"\"\n    @dev Returns `True` if this contract implements the\n         interface defined by `interfaceId`.\n    @notice For more details on how these identifiers are\n            created, please refer to:\n            https://eips.ethereum.org/EIPS/eip-165.\n    @param interfaceId The 4-byte interface identifier.\n    @return bool The verification whether the contract\n            implements the interface or not.\n    \"\"\"\n    ...\n",
      "sha256sum": "9ab4fb77ed1cf09b95c1b0b33bbc34488d41cc081d77fef73888e2591a72c6ec"
    },
    "contracts/interfaces/IERC5267.vyi": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-5267 Interface Definition\n@custom:contract-name IERC5267\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice The ERC-5267 standard complements the EIP-712 standard\n        by standardising how contracts should publish the fields\n        and values that describe their domain. This enables\n        applications to retrieve this description and generate\n        appropriate domain separators in a general way, and thus\n        integrate EIP-712 signatures securely and scalably. For\n        more details, please refer to:\n        https://eips.ethereum.org/EIPS/eip-5267.\n\n        Note that Vyper interfaces that implement functions\n        with return values that require an upper bound (e.g.\n        `Bytes`, `DynArray`, or `String`), the upper bound\n        defined in the interface represents the lower bound\n        of the implementation:\n        https://github.com/vyperlang/vyper/pull/3205.\n\n        On how to use interfaces in Vyper, please visit:\n        https://vyper.readthedocs.io/en/latest/interfaces.html#interfaces.\n\"\"\"\n\n\n# @dev May be emitted to signal that the domain could\n# have changed.\nevent EIP712DomainChanged:\n    pass\n\n\n@external\n@view\ndef eip712Domain() -> (\n    bytes1,\n    String[50],\n    String[20],\n    uint256,\n    address,\n    bytes32,\n    DynArray[uint256, 32],\n):\n    \"\"\"\n    @dev Returns the fields and values that describe the domain\n         separator used by this contract for EIP-712 signatures.\n    @notice The bits in the 1-byte bit map are read from the least\n            significant to the most significant, and fields are indexed\n            in the order that is specified by EIP-712, identical to the\n            order in which they are listed in the function type.\n    @return bytes1 The 1-byte bit map where bit `i` is set to `1`\n            if and only if domain field `i` is present (`0 \u2264 i \u2264 4`).\n    @return String The maximum 50-character user-readable string name\n            of the signing domain, i.e. the name of the dApp or protocol.\n    @return String The maximum 20-character current main version of\n            the signing domain. Signatures from different versions are\n            not compatible.\n    @return uint256 The 32-byte EIP-155 chain ID.\n    @return address The 20-byte address of the verifying contract.\n    @return bytes32 The 32-byte disambiguation salt for the protocol.\n    @return DynArray The 32-byte array of EIP-712 extensions.\n    \"\"\"\n    ...\n",
      "sha256sum": "befa8617bb875f2142309c8760c5dddf162f89683b32f72ce3aa097fa86ea850"
    },
    "contracts/interfaces/IERC721Receiver.vyi": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-721 Token Receiver Interface Definition\n@custom:contract-name IERC721Receiver\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice The interface definition for any contract\n        that wants to support safe transfers from\n        ERC-721 asset contracts. For more details,\n        please refer to:\n        https://eips.ethereum.org/EIPS/eip-721#specification.\n\n        On how to use interfaces in Vyper, please visit:\n        https://vyper.readthedocs.io/en/latest/interfaces.html#interfaces.\n\"\"\"\n\n\n@external\ndef onERC721Received(\n    _operator: address, _from: address, _tokenId: uint256, _data: Bytes[1_024]\n) -> bytes4:\n    \"\"\"\n    @dev Whenever a `_tokenId` token is transferred to\n         this contract via `safeTransferFrom` by\n         `_operator` from `_from`, this function is called.\n    @notice It must return its function selector to\n            confirm the token transfer. If any other value\n            is returned or the interface is not implemented\n            by the recipient, the transfer will be reverted.\n    @param _operator The 20-byte address which called\n           the `safeTransferFrom` function.\n    @param _from The 20-byte address which previously\n           owned the token.\n    @param _tokenId The 32-byte identifier of the token.\n    @param _data The maximum 1,024-byte additional data\n           with no specified format.\n    @return bytes4 The 4-byte function selector of `onERC721Received`.\n    \"\"\"\n    ...\n",
      "sha256sum": "8b4304d2f5676d3a898331ca2c101919365486b4893d9c98a8a493312f081579"
    },
    "contracts/imports/ownable.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Owner-Based Access Control Functions\n@custom:contract-name ownable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement a basic access\n        control mechanism, where there is an account (an owner)\n        that can be granted exclusive access to specific functions.\n        By default, the owner account will be the one that deploys\n        the contract. This can later be changed with `transfer_ownership`.\n        An exemplary integration can be found in the ERC-20 implementation here:\n        https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/tokens/erc20.vy.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol.\n\"\"\"\n\n\n# @dev Returns the address of the current owner.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\nowner: public(address)\n\n\n# @dev Emitted when the ownership is transferred\n# from `previous_owner` to `new_owner`.\nevent OwnershipTransferred:\n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice The `owner` role will be assigned to\n            the `msg.sender`.\n    \"\"\"\n    self._transfer_ownership(msg.sender)\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    self._check_owner()\n    assert new_owner != empty(address), \"ownable: new owner is the zero address\"\n    self._transfer_ownership(new_owner)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner.\n    \"\"\"\n    self._check_owner()\n    self._transfer_ownership(empty(address))\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"ownable: caller is not the owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice This is an `internal` function without\n            access restriction.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n",
      "sha256sum": "122afa017754eb8c1797a14df6464cc46db30de08bac7660d6b1d50e4093a74b"
    },
    "contracts/imports/ecdsa.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Elliptic Curve Digital Signature Algorithm (ECDSA) Secp256k1-Based Functions\n@custom:contract-name ecdsa\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to verify that a message was signed by\n        the holder of the private key of a given address. All cryptographic\n        calculations are based on the Ethereum-native secp256k1 elliptic curve\n        (see https://en.bitcoin.it/wiki/Secp256k1). For verification functions\n        based on the NIST P-256 elliptic curve (also known as secp256r1), see\n        the {p256} contract. The implementation is inspired by OpenZeppelin's\n        implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol.\n@custom:security Signatures must not be used as unique identifiers since the\n                 `ecrecover` EVM precompile allows for malleable (non-unique)\n                 signatures (see EIP-2: https://eips.ethereum.org/EIPS/eip-2)\n                 or signatures can be malleablised using EIP-2098:\n                 https://eips.ethereum.org/EIPS/eip-2098.\n\"\"\"\n\n\n# @dev The malleability threshold used as part of the ECDSA\n# verification function.\n_MALLEABILITY_THRESHOLD: constant(uint256) = (\n    57_896_044_618_658_097_711_785_492_504_343_953_926_418_782_139_537_452_191_302_581_570_759_080_747_168\n)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    \"\"\"\n    pass\n\n\n@internal\n@pure\ndef _recover_sig(hash: bytes32, signature: Bytes[65]) -> address:\n    \"\"\"\n    @dev Recovers the signer address from a message digest `hash`\n         and the signature `signature`.\n    @notice WARNING: This function is vulnerable to a kind of\n            signature malleability due to accepting EIP-2098\n            compact signatures in addition to the traditional\n            65-byte signature format. The potentially affected\n            contracts are those that implement signature reuse\n            or replay protection by marking the signature itself\n            as used rather than the signed message or a nonce\n            included in it. A user may take a signature that has\n            already been submitted, submit it again in a different\n            form, and bypass this protection. Also, see OpenZeppelin's\n            security advisory for more information:\n            https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h.\n    @param hash The 32-byte message digest that was signed.\n    @param signature The secp256k1 64/65-byte signature of `hash`.\n    @return address The recovered 20-byte signer address.\n    \"\"\"\n    sig_length: uint256 = len(signature)\n    # 65-byte case: `(r,s,v)` standard signature.\n    if sig_length == 65:\n        r: uint256 = extract32(signature, empty(uint256), output_type=uint256)\n        s: uint256 = extract32(signature, 32, output_type=uint256)\n        v: uint256 = convert(slice(signature, 64, 1), uint256)\n        return self._try_recover_vrs(hash, v, r, s)\n    # 64-byte case: `(r,vs)` signature; see: https://eips.ethereum.org/EIPS/eip-2098.\n    elif sig_length == 64:\n        r: uint256 = extract32(signature, empty(uint256), output_type=uint256)\n        vs: uint256 = extract32(signature, 32, output_type=uint256)\n        return self._try_recover_r_vs(hash, r, vs)\n\n    return empty(address)\n\n\n@internal\n@pure\ndef _recover_vrs(hash: bytes32, v: uint256, r: uint256, s: uint256) -> address:\n    \"\"\"\n    @dev Recovers the signer address from a message digest `hash`\n         and the secp256k1 signature parameters `v`, `r`, and `s`.\n    @param hash The 32-byte message digest that was signed.\n    @param v The secp256k1 1-byte signature parameter `v`.\n    @param r The secp256k1 32-byte signature parameter `r`.\n    @param s The secp256k1 32-byte signature parameter `s`.\n    @return address The recovered 20-byte signer address.\n    \"\"\"\n    return self._try_recover_vrs(hash, v, r, s)\n\n\n@internal\n@pure\ndef _try_recover_r_vs(hash: bytes32, r: uint256, vs: uint256) -> address:\n    \"\"\"\n    @dev Recovers the signer address from a message digest `hash`\n         and the secp256k1 short signature fields `r` and `vs`.\n    @notice See https://eips.ethereum.org/EIPS/eip-2098 for the\n            compact signature representation.\n    @param hash The 32-byte message digest that was signed.\n    @param r The secp256k1 32-byte signature parameter `r`.\n    @param vs The secp256k1 32-byte short signature field of `v` and `s`.\n    @return address The recovered 20-byte signer address.\n    \"\"\"\n    s: uint256 = vs & convert(max_value(int256), uint256)\n    # We do not check for an overflow here, as the shift operation\n    # `vs >> 255` results in `0` or `1`.\n    v: uint256 = unsafe_add(vs >> 255, 27)\n    return self._try_recover_vrs(hash, v, r, s)\n\n\n@internal\n@pure\ndef _try_recover_vrs(\n    hash: bytes32, v: uint256, r: uint256, s: uint256\n) -> address:\n    \"\"\"\n    @dev Recovers the signer address from a message digest `hash`\n         and the secp256k1 signature parameters `v`, `r`, and `s`.\n    @notice All client implementations of the precompile `ecrecover`\n            check if the value of `v` is `27` or `28`. The references\n            for the different client implementations can be found here:\n            https://github.com/ethereum/yellowpaper/pull/860. Thus,\n            the signature check on the value of `v` is neglected.\n    @param hash The 32-byte message digest that was signed.\n    @param v The secp256k1 1-byte signature parameter `v`.\n    @param r The secp256k1 32-byte signature parameter `r`.\n    @param s The secp256k1 32-byte signature parameter `s`.\n    @return address The recovered 20-byte signer address.\n    \"\"\"\n    assert s <= _MALLEABILITY_THRESHOLD, \"ecdsa: invalid signature `s` value\"\n\n    signer: address = ecrecover(hash, v, r, s)\n    assert signer != empty(address), \"ecdsa: invalid signature\"\n\n    return signer\n",
      "sha256sum": "0d572f0b6e49240a7bb6ba7a60d37de7b6796bf9b1889ad5e9018d6f8a5a463e"
    },
    "contracts/imports/message_hash_utils.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Signature Message Hash Utility Functions\n@custom:contract-name message_hash_utils\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to generate message hashes that conform\n        to the EIP-191 (https://eips.ethereum.org/EIPS/eip-191) as well as\n        EIP-712 (https://eips.ethereum.org/EIPS/eip-712) specifications. The\n        implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MessageHashUtils.sol.\n\"\"\"\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    \"\"\"\n    pass\n\n\n@internal\n@pure\ndef _to_eth_signed_message_hash(hash: bytes32) -> bytes32:\n    \"\"\"\n    @dev Returns an Ethereum signed message from a 32-byte\n         message digest `hash`.\n    @notice This function returns a 32-byte hash that\n            corresponds to the one signed with the JSON-RPC method:\n            https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign.\n            This method is part of EIP-191:\n            https://eips.ethereum.org/EIPS/eip-191.\n    @param hash The 32-byte message digest.\n    @return bytes32 The 32-byte Ethereum signed message.\n    \"\"\"\n    return keccak256(concat(b\"\\x19Ethereum Signed Message:\\n32\", hash))\n\n\n@internal\n@view\ndef _to_data_with_intended_validator_hash_self(data: Bytes[1_024]) -> bytes32:\n    \"\"\"\n    @dev Returns an Ethereum signed data with this contract\n         as the intended validator and a maximum 1,024-byte\n         payload `data`.\n    @notice This function structures the data according to\n            the version `0x00` of EIP-191:\n            https://eips.ethereum.org/EIPS/eip-191#version-0x00.\n    @param data The maximum 1,024-byte data to be signed.\n    @return bytes32 The 32-byte Ethereum signed data.\n    \"\"\"\n    return self._to_data_with_intended_validator_hash(self, data)\n\n\n@internal\n@pure\ndef _to_data_with_intended_validator_hash(\n    validator: address, data: Bytes[1_024]\n) -> bytes32:\n    \"\"\"\n    @dev Returns an Ethereum signed data with `validator` as\n         the intended validator and a maximum 1,024-byte payload\n         `data`.\n    @notice This function structures the data according to\n            the version `0x00` of EIP-191:\n            https://eips.ethereum.org/EIPS/eip-191#version-0x00.\n    @param validator The 20-byte intended validator address.\n    @param data The maximum 1,024-byte data to be signed.\n    @return bytes32 The 32-byte Ethereum signed data.\n    \"\"\"\n    return keccak256(concat(b\"\\x19\\x00\", convert(validator, bytes20), data))\n\n\n@internal\n@pure\ndef _to_typed_data_hash(\n    domain_separator: bytes32, struct_hash: bytes32\n) -> bytes32:\n    \"\"\"\n    @dev Returns an Ethereum signed typed data from a 32-byte\n         `domain_separator` and a 32-byte `struct_hash`.\n    @notice This function returns a 32-byte hash that\n            corresponds to the one signed with the JSON-RPC method:\n            https://eips.ethereum.org/EIPS/eip-712#specification-of-the-eth_signtypeddata-json-rpc.\n            This method is part of EIP-712:\n            https://eips.ethereum.org/EIPS/eip-712.\n    @param domain_separator The 32-byte domain separator that is\n           used as part of the EIP-712 encoding scheme.\n    @param struct_hash The 32-byte struct hash that is used as\n           part of the EIP-712 encoding scheme. See the definition:\n           https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    @return bytes32 The 32-byte Ethereum signed typed data.\n    \"\"\"\n    return keccak256(concat(b\"\\x19\\x01\", domain_separator, struct_hash))\n",
      "sha256sum": "18184b9a90277479777cedb8fb7bf5844c5553201a6a56338b74db83efaa171a"
    },
    "contracts/imports/eip712_domain_separator.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title EIP-712 Domain Separator\n@custom:contract-name eip712_domain_separator\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions are part of EIP-712: https://eips.ethereum.org/EIPS/eip-712.\n        These functions implement the version of encoding known\n        as \"v4\" as implemented by the JSON-RPC method:\n        https://docs.metamask.io/guide/signing-data.html#sign-typed-data-v4.\n        In addition, this contract also implements EIP-5267:\n        https://eips.ethereum.org/EIPS/eip-5267.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol.\n\"\"\"\n\n\n# @dev We import and implement the `IERC5267` interface,\n# which is written using standard Vyper syntax.\nfrom ..interfaces import IERC5267\n\nimplements: IERC5267\n\n\n# @dev We import the `message_hash_utils` module.\n# @notice Please note that the `message_hash_utils`\n# module is stateless and therefore does not require\n# the `uses` keyword for usage.\nfrom . import message_hash_utils\n\n\n# @dev The 32-byte type hash for the EIP-712 domain separator.\n_TYPE_HASH: constant(bytes32) = keccak256(\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n)\n\n\n# @dev Caches the domain separator as an `immutable`\n# value, but also stores the corresponding chain ID\n# to invalidate the cached domain separator if the\n# chain ID changes.\n_CACHED_DOMAIN_SEPARATOR: immutable(bytes32)\n_CACHED_CHAIN_ID: immutable(uint256)\n\n\n# @dev Caches `self` to `immutable` storage to avoid\n# potential issues if a vanilla contract is used in\n# a `delegatecall` context.\n_CACHED_SELF: immutable(address)\n\n\n# @dev `immutable` variables to store the (hashed)\n# name and (hashed) version during contract creation.\n_NAME: immutable(String[50])\n_HASHED_NAME: immutable(bytes32)\n_VERSION: immutable(String[20])\n_HASHED_VERSION: immutable(bytes32)\n\n\n@deploy\n@payable\ndef __init__(name_: String[50], version_: String[20]):\n    \"\"\"\n    @dev Initialises the domain separator and the parameter caches.\n         To omit the opcodes for checking the `msg.value` in the\n         creation-time EVM bytecode, the constructor is declared as\n         `payable`.\n    @notice The definition of the domain separator can be found here:\n            https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator.\n            Since the Vyper design requires strings of fixed size,\n            we arbitrarily set the maximum length for `name` to 50\n            characters and `version` to 20 characters.\n    @param name_ The maximum 50-character user-readable string name\n           of the signing domain, i.e. the name of the dApp or protocol.\n    @param version_ The maximum 20-character current main version of\n           the signing domain. Signatures from different versions are\n           not compatible.\n    \"\"\"\n    _NAME = name_\n    _VERSION = version_\n    _HASHED_NAME = keccak256(name_)\n    _HASHED_VERSION = keccak256(version_)\n    _CACHED_DOMAIN_SEPARATOR = self._build_domain_separator()\n    _CACHED_CHAIN_ID = chain.id\n    _CACHED_SELF = self\n\n\n@external\n@view\ndef eip712Domain() -> (\n    bytes1,\n    String[50],\n    String[20],\n    uint256,\n    address,\n    bytes32,\n    DynArray[uint256, 32],\n):\n    \"\"\"\n    @dev Returns the fields and values that describe the domain\n         separator used by this contract for EIP-712 signatures.\n    @notice The bits in the 1-byte bit map are read from the least\n            significant to the most significant, and fields are indexed\n            in the order that is specified by EIP-712, identical to the\n            order in which they are listed in the function type.\n    @return bytes1 The 1-byte bit map where bit `i` is set to `1`\n            if and only if domain field `i` is present (`0 \u2264 i \u2264 4`).\n    @return String The maximum 50-character user-readable string name\n            of the signing domain, i.e. the name of the dApp or protocol.\n    @return String The maximum 20-character current main version of\n            the signing domain. Signatures from different versions are\n            not compatible.\n    @return uint256 The 32-byte EIP-155 chain ID.\n    @return address The 20-byte address of the verifying contract.\n    @return bytes32 The 32-byte disambiguation salt for the protocol.\n    @return DynArray The 32-byte array of EIP-712 extensions.\n    \"\"\"\n    # Note that `0x0f` equals `01111`.\n    return (\n        0x0f,\n        _NAME,\n        _VERSION,\n        chain.id,\n        self,\n        empty(bytes32),\n        empty(DynArray[uint256, 32]),\n    )\n\n\n@internal\n@view\ndef _domain_separator_v4() -> bytes32:\n    \"\"\"\n    @dev Returns the domain separator for the current chain.\n    @return bytes32 The 32-byte domain separator.\n    \"\"\"\n    if self == _CACHED_SELF and chain.id == _CACHED_CHAIN_ID:\n        return _CACHED_DOMAIN_SEPARATOR\n\n    return self._build_domain_separator()\n\n\n@internal\n@view\ndef _build_domain_separator() -> bytes32:\n    \"\"\"\n    @dev Builds the domain separator for the current chain.\n    @return bytes32 The 32-byte domain separator.\n    \"\"\"\n    return keccak256(\n        abi_encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, chain.id, self)\n    )\n\n\n@internal\n@view\ndef _hash_typed_data_v4(struct_hash: bytes32) -> bytes32:\n    \"\"\"\n    @dev Returns the hash of the fully encoded EIP-712\n         message for this domain.\n    @notice The definition of the hashed struct can be found here:\n            https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    @param struct_hash The 32-byte hashed struct.\n    @return bytes32 The 32-byte fully encoded EIP712\n            message hash for this domain.\n    \"\"\"\n    return message_hash_utils._to_typed_data_hash(\n        self._domain_separator_v4(), struct_hash\n    )\n",
      "sha256sum": "42cd04ca869c12b9be56d9de750060fe074dfdf6926b50020c09939c32941c8a"
    },
    "contracts/AuctionNFT.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Modern and Gas-Efficient ERC-721 + EIP-4494 Implementation\n@custom:contract-name erc721\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions implement the ERC-721\n        standard interface:\n        - https://eips.ethereum.org/EIPS/eip-721.\n        In addition, the following functions have\n        been added for convenience:\n        - `name` (`external` `view` function),\n        - `symbol` (`external` `view` function),\n        - `tokenURI` (`external` `view` function),\n        - `totalSupply` (`external` `view` function),\n        - `tokenByIndex` (`external` `view` function),\n        - `tokenOfOwnerByIndex` (`external` `view` function),\n        - `burn` (`external` function),\n        - `is_minter` (`external` `view` function),\n        - `safe_mint` (`external` function),\n        - `set_minter` (`external` function),\n        - `permit` (`external` function),\n        - `nonces` (`external` `view` function),\n        - `DOMAIN_SEPARATOR` (`external` `view` function),\n        - `eip712Domain` (`external` `view` function),\n        - `owner` (`external` `view` function),\n        - `transfer_ownership` (`external` function),\n        - `renounce_ownership` (`external` function),\n        - `_check_on_erc721_received` (`internal` function),\n        - `_before_token_transfer` (`internal` function),\n        - `_after_token_transfer` (`internal` function).\n        The `permit` function implements approvals via\n        EIP-712 secp256k1 signatures for ERC-721 tokens:\n        https://eips.ethereum.org/EIPS/eip-4494.\n        In addition, this contract also implements the EIP-5267\n        function `eip712Domain`:\n        https://eips.ethereum.org/EIPS/eip-5267.\n        Eventually, this contract also implements the EIP-4906\n        metadata update extension:\n        https://eips.ethereum.org/EIPS/eip-4906.\n        The implementation is inspired by OpenZeppelin's\n        implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol,\n        as well as by ApeAcademy's implementation here:\n        https://github.com/ApeAcademy/ERC721/blob/main/%7B%7Bcookiecutter.project_name%7D%7D/contracts/NFT.vy.\n\"\"\"\n\n\n# @dev We import and implement the `IERC165` interface,\n# which is a built-in interface of the Vyper compiler.\nfrom ethereum.ercs import IERC165\n\nimplements: IERC165\n\n\n# @dev We import and implement the `IERC721` interface,\n# which is a built-in interface of the Vyper compiler.\nfrom ethereum.ercs import IERC721\n\nimplements: IERC721\n\n\n# @dev We import and implement the `IERC721Metadata`\n# interface, which is written using standard Vyper\n# syntax.\nfrom .interfaces import IERC721Metadata\n\nimplements: IERC721Metadata\n\n\n# @dev We import and implement the `IERC721Enumerable`\n# interface, which is written using standard Vyper\n# syntax.\nfrom .interfaces import IERC721Enumerable\n\nimplements: IERC721Enumerable\n\n\n# @dev We import and implement the `IERC721Permit`\n# interface, which is written using standard Vyper\n# syntax.\nfrom .interfaces import IERC721Permit\n\nimplements: IERC721Permit\n\n\n# @dev We import and implement the `IERC4906` interface,\n# which is written using standard Vyper syntax.\nfrom .interfaces import IERC4906\n\nimplements: IERC4906\n\n\n# @dev We import and implement the `IERC5267` interface,\n# which is written using standard Vyper syntax.\nfrom .interfaces import IERC5267\n\nimplements: IERC5267\n\n\n# @dev We import the `IERC721Receiver` interface, which\n# is written using standard Vyper syntax.\nfrom .interfaces import IERC721Receiver\n\n\n# @dev We import and use the `ownable` module.\nfrom .imports import ownable\n\ninitializes: ownable\n\n\n# @dev We import the `ecdsa` module.\n# @notice Please note that the `ecdsa` module\n# is stateless and therefore does not require\n# the `uses` keyword for usage.\nfrom .imports import ecdsa\n\n\n# @dev We import and initialise the `eip712_domain_separator` module.\nfrom .imports import eip712_domain_separator\n\ninitializes: eip712_domain_separator\n\n\n# @dev We export (i.e. the runtime bytecode exposes these\n# functions externally, allowing them to be called using\n# the ABI encoding specification) the `external` getter\n# function `owner` from the `ownable` module as well as the\n# function `eip712Domain` from the `eip712_domain_separator`\n# module.\n# @notice Please note that you must always also export (if\n# required by the contract logic) `public` declared `constant`,\n# `immutable`, and state variables, for which Vyper automatically\n# generates an `external` getter function for the variable.\nexports: (\n    # @notice This ERC-721 implementation includes the `transfer_ownership`\n    # and `renounce_ownership` functions, which incorporate\n    # the additional built-in `is_minter` role logic and are\n    # therefore not exported from the `ownable` module.\n    ownable.owner,\n    eip712_domain_separator.eip712Domain,\n)\n\n\n# @dev Stores the ERC-165 interface identifier for each\n# imported interface. The ERC-165 interface identifier\n# is defined as the XOR of all function selectors in the\n# interface.\n# @notice If you are not using the full feature set of\n# this contract, please ensure you exclude the unused\n# ERC-165 interface identifiers in the main contract.\n_SUPPORTED_INTERFACES: constant(bytes4[6]) = [\n    0x01FFC9A7,  # The ERC-165 identifier for ERC-165.\n    0x80AC58CD,  # The ERC-165 identifier for ERC-721.\n    0x5B5E139F,  # The ERC-165 identifier for the ERC-721 metadata extension.\n    0x780E9D63,  # The ERC-165 identifier for the ERC-721 enumeration extension.\n    0x589C5CE2,  # The ERC-165 identifier for ERC-4494.\n    0x49064906,  # The ERC-165 identifier for ERC-4906.\n]\n\n\n# @dev The 32-byte type hash of the `permit` function.\n_PERMIT_TYPE_HASH: constant(bytes32) = keccak256(\n    \"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\"\n)\n\n\n# @dev Returns the token collection name.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable. Furthermore,\n# to preserve consistency with the interface for\n# the optional metadata functions of the ERC-721\n# standard, we use lower case letters for the\n# `immutable` variables `name` and `symbol`.\nname: public(immutable(String[25]))\n\n\n# @dev Returns the token collection symbol.\n# @notice See comment on lower case letters\n# above at `name`.\nsymbol: public(immutable(String[5]))\n\n\n# @dev Stores the base URI for computing `tokenURI`.\nbase_uri: public(String[80])\n\n\n# @dev Mapping from owner to operator approvals.\nisApprovedForAll: public(HashMap[address, HashMap[address, bool]])\n\n\n# @dev Returns `True` if an `address` has been\n# granted the minter role.\nis_minter: public(HashMap[address, bool])\n\n\n# @dev Returns the current on-chain tracked nonce\n# of `token_id`.\nnonces: public(HashMap[uint256, uint256])\n\n\n# @dev Mapping from owner address to token count.\n_balances: HashMap[address, uint256]\n\n\n# @dev Mapping from token ID to owner address.\n_owners: HashMap[uint256, address]\n\n\n# @dev Mapping from token ID to approved address.\n_token_approvals: HashMap[uint256, address]\n\n\n# @dev Mapping from owner to list of owned token IDs.\n_owned_tokens: HashMap[address, HashMap[uint256, uint256]]\n\n\n# @dev Mapping from token ID to index of the owner\n# tokens list.\n_owned_tokens_index: HashMap[uint256, uint256]\n\n\n# @dev Array with all token IDs used for enumeration.\n_all_tokens: DynArray[uint256, max_value(uint64)]\n\n\n# @dev Mapping from token ID to position in the\n# `_all_tokens` array.\n_all_tokens_index: HashMap[uint256, uint256]\n\n\n# @dev Mapping from address to auction ID to token ID.\nauction_to_token: public(HashMap[address, HashMap[uint256, uint256]])\n\n\n# @dev An `uint256` counter variable that sets\n# the token ID for each `safe_mint` call and\n# then increments.\n_counter: uint256\n\n# @dev Emitted when the status of a `minter`\n# address is changed.\nevent RoleMinterChanged:\n    minter: indexed(address)\n    status: bool\n\n\n@deploy\n@payable\ndef __init__(\n    name_: String[25],\n    symbol_: String[5],\n    base_uri_: String[80],\n    name_eip712_: String[50],\n    version_eip712_: String[20],\n):\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice At initialisation time, the `owner` role will be\n            assigned to the `msg.sender` since we `uses` the\n            `ownable` module, which implements the aforementioned\n            logic at contract creation time.\n    @param name_ The maximum 25-character user-readable string\n           name of the token collection.\n    @param symbol_ The maximum 5-character user-readable string\n           symbol of the token collection.\n    @param base_uri_ The maximum 80-character user-readable\n           string base URI for computing `tokenURI`.\n    @param name_eip712_ The maximum 50-character user-readable\n           string name of the signing domain, i.e. the name\n           of the dApp or protocol.\n    @param version_eip712_ The maximum 20-character current\n           main version of the signing domain. Signatures\n           from different versions are not compatible.\n    \"\"\"\n    self._counter = empty(uint256)\n    ownable.__init__()\n    name = name_\n    symbol = symbol_\n    self.base_uri = base_uri_\n\n    self.is_minter[msg.sender] = True\n    log RoleMinterChanged(msg.sender, True)\n\n    eip712_domain_separator.__init__(name_eip712_, version_eip712_)\n\n\n@external\n@view\ndef supportsInterface(interface_id: bytes4) -> bool:\n    \"\"\"\n    @dev Returns `True` if this contract implements the\n         interface defined by `interface_id`.\n    @param interface_id The 4-byte interface identifier.\n    @return bool The verification whether the contract\n            implements the interface or not.\n    \"\"\"\n    return interface_id in _SUPPORTED_INTERFACES\n\n\n@external\n@view\ndef balanceOf(owner: address) -> uint256:\n    \"\"\"\n    @dev Returns the amount of tokens owned by `owner`.\n    @notice Note that `owner` cannot be the zero address.\n    @param owner The 20-byte owner address.\n    @return uint256 The 32-byte token amount owned\n            by `owner`.\n    \"\"\"\n    return self._balance_of(owner)\n\n\n@external\n@view\ndef ownerOf(token_id: uint256) -> address:\n    \"\"\"\n    @dev Returns the owner of the `token_id` token.\n    @notice Note that `token_id` must exist.\n    @param token_id The 32-byte identifier of the token.\n    @return address The 20-byte owner address.\n    \"\"\"\n    return self._owner_of(token_id)\n\n\n@external\n@payable\ndef approve(to: address, token_id: uint256):\n    \"\"\"\n    @dev Gives permission to `to` to transfer\n         `token_id` token to another account.\n         The approval is cleared when the token\n         is transferred.\n    @notice Only a single account can be approved\n            at a time, so approving the zero address\n            clears previous approvals. Also, the\n            caller must own the token or be an\n            approved operator, and `token_id` must\n            exist.\n\n            IMPORTANT: The function is declared as\n            `payable` to comply with the EIP-721\n            standard definition:\n            https://eips.ethereum.org/EIPS/eip-721.\n    @param to The 20-byte spender address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    owner: address = self._owner_of(token_id)\n    assert to != owner, \"erc721: approval to current owner\"\n    assert (\n        msg.sender == owner or self.isApprovedForAll[owner][msg.sender]\n    ), \"erc721: approve caller is not token owner or approved for all\"\n    self._approve(to, token_id)\n\n\n@external\n@view\ndef getApproved(token_id: uint256) -> address:\n    \"\"\"\n    @dev Returns the account approved for `token_id`\n         token.\n    @notice Note that `token_id` must exist.\n    @param token_id The 32-byte identifier of the token.\n    @return address The 20-byte approved address.\n    \"\"\"\n    return self._get_approved(token_id)\n\n\n@external\ndef setApprovalForAll(operator: address, approved: bool):\n    \"\"\"\n    @dev Approves or removes `operator` as an operator\n         for the caller. Operators can call `transferFrom`\n         or `safeTransferFrom` for any token owned by\n         the caller.\n    @notice Note that the `operator` cannot be the caller.\n    @param operator The 20-byte operator address.\n    @param approved The Boolean variable that sets the\n           approval status.\n    \"\"\"\n    self._set_approval_for_all(msg.sender, operator, approved)\n\n\n@external\n@payable\ndef transferFrom(owner: address, to: address, token_id: uint256):\n    \"\"\"\n    @dev Transfers `token_id` token from `owner` to `to`.\n    @notice WARNING: Note that the caller is responsible\n            to confirm that the recipient is capable of\n            receiving an ERC-721 token or else they may\n            be permanently lost. Usage of `safeTransferFrom`\n            prevents loss, though the caller must understand\n            this adds an external call which potentially\n            creates a reentrancy vulnerability.\n\n            Note that `owner` and `to` cannot be the zero\n            address. Also, `token_id` token must exist and\n            must be owned by `owner`. Eventually, if the caller\n            is not `owner`, it must be approved to move this\n            token by either `approve` or `setApprovalForAll`.\n\n            IMPORTANT: The function is declared as `payable`\n            to comply with the EIP-721 standard definition:\n            https://eips.ethereum.org/EIPS/eip-721.\n    @param owner The 20-byte owner address.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    assert self._is_approved_or_owner(\n        msg.sender, token_id\n    ), \"erc721: caller is not token owner or approved\"\n    self._transfer(owner, to, token_id)\n\n\n@external\n@payable\ndef safeTransferFrom(\n    owner: address, to: address, token_id: uint256, data: Bytes[1_024] = b\"\"\n):\n    \"\"\"\n    @dev Safely transfers `token_id` token from `owner`\n         to `to`.\n    @notice Note that `owner` and `to` cannot be the zero\n            address. Also, `token_id` token must exist and\n            must be owned by `owner`. Furthermore, if the caller\n            is not `owner`, it must be approved to move this\n            token by either `approve` or `setApprovalForAll`.\n            Eventually, if `to` refers to a smart contract,\n            it must implement {IERC721Receiver-onERC721Received},\n            which is called upon a safe transfer.\n\n            The Vyper compiler processes this function `safeTransferFrom`\n            as two separate function selectors, since a default\n            parameter `b\"\"` is set in the function declaration.\n            Anyone can invoke this function using only `owner`,\n            `to`, and `token_id` as arguments, and is therefore\n            compatible with the function overloading of `safeTransferFrom`\n            in the standard ERC-721 interface. You can find more\n            information here:\n            - https://github.com/vyperlang/vyper/issues/903,\n            - https://github.com/vyperlang/vyper/pull/987.\n\n            IMPORTANT: The function is declared as `payable`\n            to comply with the EIP-721 standard definition:\n            https://eips.ethereum.org/EIPS/eip-721.\n\n            WARNING: This function can potentially allow a reentrancy\n            attack when transferring tokens to an untrusted contract,\n            when invoking {IERC721Receiver-onERC721Received} on the\n            receiver. We ensure that we consistently follow the checks-\n            effects-interactions (CEI) pattern to avoid being vulnerable\n            to this type of attack.\n    @param owner The 20-byte owner address.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    @param data The maximum 1,024-byte additional data\n           with no specified format that is sent\n           to `to`.\n    \"\"\"\n    assert self._is_approved_or_owner(\n        msg.sender, token_id\n    ), \"erc721: caller is not token owner or approved\"\n    self._safe_transfer(owner, to, token_id, data)\n\n\n@external\n@view\ndef tokenURI(token_id: uint256) -> String[512]:\n    \"\"\"\n    @dev Returns the Uniform Resource Identifier (URI)\n         for `token_id` token.\n    @notice Throws if `token_id` is not a valid ERC-721 token.\n    @param token_id The 32-byte identifier of the token.\n    @return String The maximum 512-character user-readable\n            string token URI of the `token_id` token.\n    \"\"\"\n    self._require_minted(token_id)\n\n    # If both are set, concatenate the base URI\n    # and token URI.\n    return concat(self.base_uri, uint2str(token_id))\n\n\n@external\n@view\ndef totalSupply() -> uint256:\n    \"\"\"\n    @dev Returns the amount of tokens in existence.\n    @return uint256 The 32-byte token supply.\n    \"\"\"\n    return self._total_supply()\n\n\n@external\n@view\ndef tokenByIndex(index: uint256) -> uint256:\n    \"\"\"\n    @dev Returns a token ID at a given `index` of\n         all the tokens stored by the contract.\n    @notice Use along with `totalSupply` to enumerate\n            all tokens.\n    @param index The 32-byte counter (must be less\n           than `totalSupply`).\n    @return uint256 The 32-byte token ID at index\n            `index`.\n    \"\"\"\n    assert index < self._total_supply(), \"erc721: global index out of bounds\"\n    return self._all_tokens[index]\n\n\n@external\n@view\ndef tokenOfOwnerByIndex(owner: address, index: uint256) -> uint256:\n    \"\"\"\n    @dev Returns a token ID owned by `owner` at a\n         given `index` of its token list.\n    @notice Use along with `balanceOf` to enumerate\n            all of `owner`'s tokens.\n    @param owner The 20-byte owner address.\n    @param index The 32-byte counter (must be less\n           than `balanceOf(owner)`).\n    @return uint256 The 32-byte token ID owned by\n            `owner` at index `index`.\n    \"\"\"\n    assert index < self._balance_of(owner), \"erc721: owner index out of bounds\"\n    return self._owned_tokens[owner][index]\n\n\n@external\ndef burn(token_id: uint256):\n    \"\"\"\n    @dev Burns the `token_id` token.\n    @notice Note that the caller must own `token_id`\n            or be an approved operator.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    assert self._is_approved_or_owner(\n        msg.sender, token_id\n    ), \"erc721: caller is not token owner or approved\"\n    self._burn(token_id)\n\n\n@external\ndef safe_mint(\n    owner: address, contract_address: address, auction_id: uint256\n) -> int256:\n    \"\"\"\n    @dev Safely mints `token_id` and transfers it to `owner`.\n    @notice Only authorised minters can access this function.\n            Note that `owner` cannot be the zero address.\n            Also, new tokens will be automatically assigned\n            an incremental ID.\n    @param owner The 20-byte owner address.\n    @param auction_id External auction ID\n    @return -1 on fail or NFT ID\n    \"\"\"\n    assert self.is_minter[msg.sender], \"erc721: access is denied\"\n    # New tokens will be automatically assigned an incremental ID.\n    # The first token ID will be one.\n    token_id: uint256 = self._counter + 1\n    self._counter = token_id\n    # Theoretically, the following line could overflow\n    # if all 2**256 token IDs were minted. However,\n    # since we have bounded the dynamic array `_all_tokens`\n    # by the maximum value of `uint64` and the `_counter`\n    # increments above are checked for an overflow, this is\n    # no longer even theoretically possible.\n    self._safe_mint(owner, token_id, b\"\")\n    self.auction_to_token[contract_address][auction_id] = token_id\n    log IERC4906.MetadataUpdate(token_id)\n    return convert(token_id, int256)\n\n\n@external\ndef set_base_uri(new_uri: String[80]):\n    ownable._check_owner()\n    self.base_uri = new_uri\n\n\n@external\ndef set_minter(minter: address, status: bool):\n    \"\"\"\n    @dev Adds or removes an address `minter` to/from the\n         list of allowed minters. Note that only the\n         `owner` can add or remove `minter` addresses.\n         Also, the `minter` cannot be the zero address.\n         Eventually, the `owner` cannot remove himself\n         from the list of allowed minters.\n    @param minter The 20-byte minter address.\n    @param status The Boolean variable that sets the status.\n    \"\"\"\n    ownable._check_owner()\n    assert minter != empty(address), \"erc721: minter is the zero address\"\n    # We ensured in the previous step `ownable._check_owner`\n    # that `msg.sender` is the `owner`.\n    assert minter != msg.sender, \"erc721: minter is owner address\"\n    self.is_minter[minter] = status\n    log RoleMinterChanged(minter, status)\n\n\n@external\ndef permit(\n    spender: address,\n    token_id: uint256,\n    deadline: uint256,\n    v: uint8,\n    r: bytes32,\n    s: bytes32,\n):\n    \"\"\"\n    @dev Sets permission to `spender` to transfer `token_id`\n         token to another account, given `owner`'s signed\n         approval.\n    @notice Note that `spender` cannot be the zero address.\n            Also, `deadline` must be a block timestamp in\n            the future. `v`, `r`, and `s` must be a valid\n            secp256k1 signature from `owner` over the\n            EIP-712-formatted function arguments. Eventually,\n            the signature must use `token_id`'s current nonce.\n    @param spender The 20-byte spender address.\n    @param token_id The 32-byte identifier of the token.\n    @param deadline The 32-byte block timestamp up\n           which the `spender` is allowed to spend `token_id`.\n    @param v The secp256k1 1-byte signature parameter `v`.\n    @param r The secp256k1 32-byte signature parameter `r`.\n    @param s The secp256k1 32-byte signature parameter `s`.\n    \"\"\"\n    assert block.timestamp <= deadline, \"erc721: expired deadline\"\n\n    current_nonce: uint256 = self.nonces[token_id]\n    self.nonces[token_id] = unsafe_add(current_nonce, 1)\n\n    struct_hash: bytes32 = keccak256(\n        abi_encode(\n            _PERMIT_TYPE_HASH, spender, token_id, current_nonce, deadline\n        )\n    )\n    hash: bytes32 = eip712_domain_separator._hash_typed_data_v4(struct_hash)\n\n    signer: address = ecdsa._recover_vrs(\n        hash, convert(v, uint256), convert(r, uint256), convert(s, uint256)\n    )\n    assert signer == self._owner_of(token_id), \"erc721: invalid signature\"\n\n    self._approve(spender, token_id)\n\n\n@external\n@view\ndef DOMAIN_SEPARATOR() -> bytes32:\n    \"\"\"\n    @dev Returns the domain separator for the current chain.\n    @return bytes32 The 32-byte domain separator.\n    \"\"\"\n    return eip712_domain_separator._domain_separator_v4()\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n\n            WARNING: The ownership transfer also removes\n            the previous owner's minter role and assigns\n            the minter role to `new_owner` accordingly.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    ownable._check_owner()\n    assert new_owner != empty(address), \"erc721: new owner is the zero address\"\n\n    self.is_minter[msg.sender] = False\n    log RoleMinterChanged(msg.sender, False)\n\n    ownable._transfer_ownership(new_owner)\n    self.is_minter[new_owner] = True\n    log RoleMinterChanged(new_owner, True)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner. Note\n            that the `owner` is also removed from\n            the list of allowed minters.\n\n            WARNING: All other existing `minter`\n            addresses will still be able to create\n            new tokens. Consider removing all non-owner\n            minter addresses first via `set_minter`\n            before calling `renounce_ownership`.\n    \"\"\"\n    ownable._check_owner()\n    self.is_minter[msg.sender] = False\n    log RoleMinterChanged(msg.sender, False)\n    ownable._transfer_ownership(empty(address))\n\n\n@internal\n@view\ndef _balance_of(owner: address) -> uint256:\n    \"\"\"\n    @dev An `internal` helper function that returns the\n         amount of tokens owned by `owner`.\n    @notice Note that `owner` cannot be the zero address.\n    @param owner The 20-byte owner address.\n    @return uint256 The 32-byte token amount owned\n            by `owner`.\n    \"\"\"\n    assert owner != empty(\n        address\n    ), \"erc721: the zero address is not a valid owner\"\n    return self._balances[owner]\n\n\n@internal\n@view\ndef _owner_of(token_id: uint256) -> address:\n    \"\"\"\n    @dev An `internal` helper function that returns the\n         owner of the `token_id` token.\n    @notice Note that `token_id` must exist.\n    @param token_id The 32-byte identifier of the token.\n    @return address The 20-byte owner address.\n    \"\"\"\n    owner: address = self._owners[token_id]\n    assert owner != empty(address), \"erc721: invalid token ID\"\n    return owner\n\n\n@internal\n@view\ndef _require_minted(token_id: uint256):\n    \"\"\"\n    @dev Reverts if the `token_id` has not yet been minted.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    assert self._exists(token_id), \"erc721: invalid token ID\"\n\n\n@internal\n@view\ndef _exists(token_id: uint256) -> bool:\n    \"\"\"\n    @dev Returns whether `token_id` exists.\n    @notice Tokens can be managed by their owner or approved\n            accounts via `approve` or `setApprovalForAll`.\n            Tokens start existing when they are minted (`_mint`),\n            and stop existing when they are burned (`_burn`).\n    @param token_id The 32-byte identifier of the token.\n    @return bool The verification whether `token_id` exists\n            or not.\n    \"\"\"\n    return self._owners[token_id] != empty(address)\n\n\n@internal\ndef _approve(to: address, token_id: uint256):\n    \"\"\"\n    @dev Approves `to` to operate on `token_id`.\n    @param to The 20-byte spender address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    self._token_approvals[token_id] = to\n    log IERC721.Approval(self._owner_of(token_id), to, token_id)\n\n\n@internal\n@view\ndef _get_approved(token_id: uint256) -> address:\n    \"\"\"\n    @dev An `internal` helper function that returns the\n         account approved for `token_id` token.\n    @notice Note that `token_id` must exist.\n    @param token_id The 32-byte identifier of the token.\n    @return address The 20-byte approved address.\n    \"\"\"\n    self._require_minted(token_id)\n    return self._token_approvals[token_id]\n\n\n@internal\ndef _set_approval_for_all(owner: address, operator: address, approved: bool):\n    \"\"\"\n    @dev Approves `operator` to operate on all of `owner` tokens.\n    @param owner The 20-byte owner address.\n    @param operator The 20-byte operator address.\n    @param approved The Boolean variable that sets the\n           approval status.\n    \"\"\"\n    assert owner != operator, \"erc721: approve to caller\"\n    self.isApprovedForAll[owner][operator] = approved\n    log IERC721.ApprovalForAll(owner, operator, approved)\n\n\n@internal\ndef _is_approved_or_owner(spender: address, token_id: uint256) -> bool:\n    \"\"\"\n    @dev Returns whether `spender` is allowed to manage\n         `token_id`.\n    @notice Note that `token_id` must exist.\n    @param spender The 20-byte spender address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    owner: address = self._owner_of(token_id)\n    return (\n        (spender == owner)\n        or (self.isApprovedForAll[owner][spender])\n        or (self._get_approved(token_id) == spender)\n    )\n\n\n@internal\ndef _safe_mint(owner: address, token_id: uint256, data: Bytes[1_024]):\n    \"\"\"\n    @dev Safely mints `token_id` and transfers it to `owner`.\n    @notice Note that `token_id` must not exist. Also, if `owner`\n            refers to a smart contract, it must implement\n            {IERC721Receiver-onERC721Received}, which is called\n            upon a safe transfer.\n\n            WARNING: This `internal` function without access\n            restriction can potentially allow a reentrancy\n            attack when transferring tokens to an untrusted\n            contract, when invoking {IERC721Receiver-onERC721Received}\n            on the receiver. We ensure that we consistently\n            follow the checks-effects-interactions (CEI) pattern\n            to avoid being vulnerable to this type of attack.\n    @param owner The 20-byte owner address.\n    @param token_id The 32-byte identifier of the token.\n    @param data The maximum 1,024-byte additional data\n           with no specified format that is sent\n           to `owner`.\n    \"\"\"\n    self._mint(owner, token_id)\n    assert self._check_on_erc721_received(\n        empty(address), owner, token_id, data\n    ), \"erc721: transfer to non-IERC721Receiver implementer\"\n\n\n@internal\ndef _mint(owner: address, token_id: uint256):\n    \"\"\"\n    @dev Mints `token_id` and transfers it to `owner`.\n    @notice Note that `token_id` must not exist and\n            `owner` cannot be the zero address.\n\n            WARNING: Usage of this method is discouraged,\n            use `_safe_mint` whenever possible.\n    @param owner The 20-byte owner address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    assert owner != empty(address), \"erc721: mint to the zero address\"\n    assert not self._exists(token_id), \"erc721: token already minted\"\n\n    self._before_token_transfer(empty(address), owner, token_id)\n    # Checks that the `token_id` was not minted by the\n    # `_before_token_transfer` hook.\n    assert not self._exists(token_id), \"erc721: token already minted\"\n\n    # Theoretically, the following line could overflow\n    # if all 2**256 token IDs were minted to the same owner.\n    # However, since we have bounded the dynamic array\n    # `_all_tokens` by the maximum value of `uint64`,\n    # this is no longer even theoretically possible.\n    self._balances[owner] = unsafe_add(self._balances[owner], 1)\n    self._owners[token_id] = owner\n    log IERC721.Transfer(empty(address), owner, token_id)\n\n    self._after_token_transfer(empty(address), owner, token_id)\n\n\n@internal\ndef _safe_transfer(\n    owner: address, to: address, token_id: uint256, data: Bytes[1_024]\n):\n    \"\"\"\n    @dev Safely transfers `token_id` token from\n         `owner` to `to`, checking first that contract\n         recipients are aware of the ERC-721 protocol\n         to prevent tokens from being forever locked.\n    @notice This `internal` function is equivalent to\n            `safeTransferFrom`, and can be used to e.g.\n            implement alternative mechanisms to perform\n            token transfers, such as signature-based.\n\n            Note that `owner` and `to` cannot be the zero\n            address. Also, `token_id` token must exist and\n            must be owned by `owner`. Eventually, if `to`\n            refers to a smart contract, it must implement\n            {IERC721Receiver-onERC721Received}, which is\n            called upon a safe transfer.\n\n            WARNING: This `internal` function can potentially\n            allow a reentrancy attack when transferring tokens\n            to an untrusted contract, when invoking {IERC721Receiver-onERC721Received}\n            on the receiver. We ensure that we consistently\n            follow the checks-effects-interactions (CEI) pattern\n            to avoid being vulnerable to this type of attack.\n    @param owner The 20-byte owner address.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    @param data The maximum 1,024-byte additional data\n           with no specified format that is sent\n           to `to`.\n    \"\"\"\n    self._transfer(owner, to, token_id)\n    assert self._check_on_erc721_received(\n        owner, to, token_id, data\n    ), \"erc721: transfer to non-IERC721Receiver implementer\"\n\n\n@internal\ndef _transfer(owner: address, to: address, token_id: uint256):\n    \"\"\"\n    @dev Transfers `token_id` from `owner` to `to`.\n         As opposed to `transferFrom`, this imposes\n         no restrictions on `msg.sender`.\n    @notice Note that `to` cannot be the zero address.\n            Also, `token_id` token must be owned by\n            `owner`.\n    @param owner The 20-byte owner address.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    assert (\n        self._owner_of(token_id) == owner\n    ), \"erc721: transfer from incorrect owner\"\n    assert to != empty(address), \"erc721: transfer to the zero address\"\n\n    self._before_token_transfer(owner, to, token_id)\n    # Checks that the `token_id` was not transferred by the\n    # `_before_token_transfer` hook.\n    assert (\n        self._owner_of(token_id) == owner\n    ), \"erc721: transfer from incorrect owner\"\n\n    self._token_approvals[token_id] = empty(address)\n    # See comment why an overflow is not possible in the\n    # following two lines above at `_mint`.\n    self._balances[owner] = unsafe_sub(self._balances[owner], 1)\n    self._balances[to] = unsafe_add(self._balances[to], 1)\n    self._owners[token_id] = to\n    log IERC721.Transfer(owner, to, token_id)\n\n    self._after_token_transfer(owner, to, token_id)\n\n\n@internal\n@view\ndef _total_supply() -> uint256:\n    \"\"\"\n    @dev An `internal` helper function that returns the amount\n         of tokens in existence.\n    @return uint256 The 32-byte token supply.\n    \"\"\"\n    return len(self._all_tokens)\n\n\n@internal\ndef _burn(token_id: uint256):\n    \"\"\"\n    @dev Destroys `token_id`.\n    @notice The approval is cleared when the token is burned.\n            This is an `internal` function that does not check\n            if the sender is authorised to operate on the token.\n            Note that `token_id` must exist.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    owner: address = self._owner_of(token_id)\n\n    self._before_token_transfer(owner, empty(address), token_id)\n    # Updates ownership in case the `token_id` was\n    # transferred by the `_before_token_transfer` hook.\n    owner = self._owner_of(token_id)\n\n    self._token_approvals[token_id] = empty(address)\n    # Overflow is not possible, as in this case more tokens would\n    # have to be burned/transferred than the owner originally\n    # received through minting and transfer.\n    self._balances[owner] = unsafe_sub(self._balances[owner], 1)\n    self._owners[token_id] = empty(address)\n    log IERC721.Transfer(owner, empty(address), token_id)\n\n    self._after_token_transfer(owner, empty(address), token_id)\n\n\n@internal\ndef _check_on_erc721_received(\n    owner: address, to: address, token_id: uint256, data: Bytes[1_024]\n) -> bool:\n    \"\"\"\n    @dev An `internal` function that invokes {IERC721Receiver-onERC721Received}\n         on a target address. The call is not executed\n         if the target address is not a contract.\n    @param owner The 20-byte address which previously\n           owned the token.\n    @param to The 20-byte address receiver address.\n    @param token_id The 32-byte identifier of the token.\n    @param data The maximum 1,024-byte additional data\n           with no specified format.\n    @return bool The verification whether the call correctly\n            returned the expected magic value.\n    \"\"\"\n    # Contract case.\n    if to.is_contract:\n        return_value: bytes4 = extcall IERC721Receiver(to).onERC721Received(\n            msg.sender, owner, token_id, data\n        )\n        assert return_value == method_id(\n            \"onERC721Received(address,address,uint256,bytes)\",\n            output_type=bytes4,\n        ), \"erc721: transfer to non-IERC721Receiver implementer\"\n        return True\n\n    return True\n\n\n@internal\ndef _before_token_transfer(owner: address, to: address, token_id: uint256):\n    \"\"\"\n    @dev Hook that is called before any token transfer.\n         This includes minting and burning.\n    @notice The calling conditions are:\n            - when `owner` and `to` are both non-zero,\n              `owner`'s tokens will be transferred to `to`,\n            - when `owner` is zero, the tokens will\n              be minted for `to`,\n            - when `to` is zero, `owner`'s tokens will\n              be burned,\n            - `owner` and `to` are never both zero.\n    @param owner The 20-byte owner address.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    if owner == empty(address):\n        self._add_token_to_all_tokens_enumeration(token_id)\n    elif owner != to:\n        self._remove_token_from_owner_enumeration(owner, token_id)\n\n    if to == empty(address):\n        self._remove_token_from_all_tokens_enumeration(token_id)\n    elif to != owner:\n        self._add_token_to_owner_enumeration(to, token_id)\n\n\n@internal\ndef _after_token_transfer(owner: address, to: address, token_id: uint256):\n    \"\"\"\n    @dev Hook that is called after any token transfer.\n         This includes minting and burning.\n    @notice The calling conditions are:\n            - when `owner` and `to` are both non-zero,\n              `owner`'s tokens were transferred to `to`,\n            - when `owner` is zero, the tokens were\n              be minted for `to`,\n            - when `to` is zero, `owner`'s tokens will\n              be burned,\n            - `owner` and `to` are never both zero.\n    @param owner The 20-byte owner address.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    pass\n\n\n@internal\ndef _add_token_to_owner_enumeration(to: address, token_id: uint256):\n    \"\"\"\n    @dev This is an `internal` function that adds a token\n         to the ownership-tracking data structures.\n    @param to The 20-byte receiver address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    length: uint256 = self._balance_of(to)\n    self._owned_tokens[to][length] = token_id\n    self._owned_tokens_index[token_id] = length\n\n\n@internal\ndef _add_token_to_all_tokens_enumeration(token_id: uint256):\n    \"\"\"\n    @dev This is an `internal` function that adds a token\n         to the token tracking data structures.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    self._all_tokens_index[token_id] = len(self._all_tokens)\n    self._all_tokens.append(token_id)\n\n\n@internal\ndef _remove_token_from_owner_enumeration(owner: address, token_id: uint256):\n    \"\"\"\n    @dev This is an `internal` function that removes a token\n         from the ownership-tracking data structures.\n    @notice Note that while the token is not assigned a new\n            owner, the `_owned_tokens_index` mapping is NOT\n            updated: this allows for gas optimisations e.g.\n            when performing a transfer operation (avoiding\n            double writes). This function has O(1) time\n            complexity, but alters the order of the\n            `_owned_tokens` array.\n    @param owner The 20-byte owner address.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    # To prevent a gap in `owner`'s tokens array,\n    # we store the last token in the index of the\n    # token to delete, and then delete the last slot.\n    last_token_index: uint256 = self._balance_of(owner) - 1\n    token_index: uint256 = self._owned_tokens_index[token_id]\n\n    # When the token to delete is the last token,\n    # the swap operation is unnecessary.\n    if token_index != last_token_index:\n        last_token_id: uint256 = self._owned_tokens[owner][last_token_index]\n        # Moves the last token to the slot of the to-delete token.\n        self._owned_tokens[owner][token_index] = last_token_id\n        # Updates the moved token's index.\n        self._owned_tokens_index[last_token_id] = token_index\n\n    self._owned_tokens_index[token_id] = empty(uint256)\n    self._owned_tokens[owner][last_token_index] = empty(uint256)\n\n\n@internal\ndef _remove_token_from_all_tokens_enumeration(token_id: uint256):\n    \"\"\"\n    @dev This is an `internal` function that removes a token\n         from the token tracking data structures.\n    @notice This function has O(1) time complexity, but\n            alters the order of the `_all_tokens` array.\n    @param token_id The 32-byte identifier of the token.\n    \"\"\"\n    # To prevent a gap in the tokens array,\n    # we store the last token in the index\n    # of the token to delete, and then delete\n    # the last slot.\n    last_token_index: uint256 = len(self._all_tokens) - 1\n    token_index: uint256 = self._all_tokens_index[token_id]\n\n    # When the token to delete is the last token,\n    # the swap operation is unnecessary. However,\n    # since this occurs so rarely (when the last\n    # minted token is burned) that we still do the\n    # swap here to avoid the gas cost of adding\n    # an `if` statement (like in `_remove_token_from_owner_enumeration`).\n    last_token_id: uint256 = self._all_tokens[last_token_index]\n\n    # Moves the last token to the slot of the to-delete token.\n    self._all_tokens[token_index] = last_token_id\n    # Updates the moved token's index.\n    self._all_tokens_index[last_token_id] = token_index\n\n    # This also deletes the contents at the\n    # last position of the array.\n    self._all_tokens_index[token_id] = empty(uint256)\n    self._all_tokens.pop()\n",
      "sha256sum": "93d97921d915cd5e8fc31df45f88e94d4490e235e4f7b782e2ae5cf00a6c3f38"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/AuctionNFT.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "392f4b4c6a6bd3b68a77516dd5429283bffe525d0f00a6520a564b686d7784d0"
}