{
  "language": "Vyper",
  "sources": {
    "contracts/imports/ownable_2step.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Ownable 2-step\n@license MIT\n@author yearn.finance, asymmetry.finance\n@notice ownable_2step.vy is a two-step ownable contract that allows for a two-step transfer of ownership\n\"\"\"\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent PendingOwnershipTransfer:\n    old_owner: address\n    new_owner: address\n\n\nevent OwnershipTransferred:\n    old_owner: address\n    new_owner: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\nowner: public(address)\npending_owner: public(address)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice Initializes the contract setting the deployer as the initial owner\n    \"\"\"\n    self.owner = msg.sender\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Starts the ownership transfer of the contract\n         to a new account `new_owner`\n    @notice Note that this function can only be\n            called by the current `owner`. Also, there is\n            no security risk in setting `new_owner` to the\n            zero address as the default value of `pending_owner`\n            is in fact already the zero address and the zero\n            address cannot call `accept_ownership`. Eventually,\n            the function replaces the pending transfer if\n            there is one\n    @param new_owner The address of the new owner\n    \"\"\"\n    self._check_owner()\n    self.pending_owner = new_owner\n    log PendingOwnershipTransfer(self.owner, new_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @dev The new owner accepts the ownership transfer.\n    @notice Note that this function can only be\n            called by the current `pending_owner`\n    \"\"\"\n    assert self.pending_owner == msg.sender, \"!new owner\"\n    self._transfer_ownership(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner\n    \"\"\"\n    assert msg.sender == self.owner, \"!owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner` and deletes\n         any pending owner\n    @notice This is an `internal` function without\n            access restriction\n    @param new_owner The address of the new owner\n    \"\"\"\n    self.pending_owner = empty(address)\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n",
      "sha256sum": "65febf30a2b8904113177dda55aac703ed6df29a612e4a503d756c76ab678869"
    },
    "contracts/imports/pausable.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Pausable\n@license MIT\n@author Leviathan\n@notice pauseable.vy allows to implement an emergency stop mechanism that can be triggered by an authorized account\n\"\"\"\n\nimport ownable_2step as ownable\n\n\n# ============================================================================================\n# Modules\n# ============================================================================================\n\n\nuses: ownable\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent Paused:\n    account: address\n\n\nevent Unpaused:\n    account: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\npaused: public(bool)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice At initialisation time, the `owner` role will\n            be assigned to the `msg.sender` since we `uses`\n            the `ownable` module, which implements the\n            aforementioned logic at contract creation time.\n    \"\"\"\n    pass\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef pause():\n    \"\"\"\n    @dev Pauses the contract\n    \"\"\"\n    ownable._check_owner()\n    self._check_unpaused()\n    self.paused = True\n    log Paused(msg.sender)\n\n\n@external\ndef unpause():\n    \"\"\"\n    @dev Unpauses the contract\n    \"\"\"\n    ownable._check_owner()\n    self._check_paused()\n    self.paused = False\n    log Unpaused(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_unpaused():\n    \"\"\"\n    @dev Checks if the contract is unpaused\n    \"\"\"\n    assert not self.paused, \"paused\"\n\n\n@internal\ndef _check_paused():\n    \"\"\"\n    @dev Checks if the contract is paused\n    \"\"\"\n    assert self.paused, \"!paused\"\n",
      "sha256sum": "5a62cf2f1a9c567df539c5488b510362dc6ea62b9b0b1ca2c4d894c26e54de8f"
    },
    "contracts/AuctionBlock.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Auction Block\n@author Leviathan\n@license MIT\n@notice Core auction contract implementing English auction mechanics with extensions\n@dev Implements:\n     - Single-price English auctions with configurable parameters\n     - Anti-sniping through time buffer extension\n     - Fee distribution system\n     - Emergency controls (pause/nullify)\n     - Delegated bidding permissions\n     - Tokens are always collected before bid state changes\n\"\"\"\n\n\n# ============================================================================================\n# \u2699\ufe0f Modules\n# ============================================================================================\n\nfrom ethereum.ercs import IERC20\n\nfrom .imports import ownable_2step as ownable\nfrom .imports import pausable\n\ninitializes: ownable\nexports: (\n    ownable.owner,\n    ownable.pending_owner,\n    ownable.transfer_ownership,\n    ownable.accept_ownership,\n)\n\ninitializes: pausable[ownable := ownable]\nexports: (\n    pausable.paused,\n    pausable.pause,\n    pausable.unpause,\n)\n\n# ============================================================================================\n# \ud83e\udde9 Interfaces\n# ============================================================================================\n\ninterface AuctionDirectory:\n    def mint_nft(owner: address, auction_id: uint256): nonpayable\n\n\n# ============================================================================================\n# \ud83c\udfe2 Structs\n# ============================================================================================\n\nstruct Auction:\n    auction_id: uint256\n    amount: uint256\n    start_time: uint256\n    end_time: uint256\n    bidder: address\n    settled: bool\n    ipfs_hash: String[46]\n    params: AuctionParams\n\n\nstruct AuctionParams:\n    time_buffer: uint256\n    reserve_price: uint256\n    min_bid_increment_percentage: uint256\n    duration: uint256\n\n\nflag ApprovalStatus:\n    Nothing  # Default value, indicating no approval\n    BidOnly  # Approved for bid only\n    WithdrawOnly  # Approved for withdraw only\n    BidAndWithdraw  # Approved for both bid and withdraw\n\n\n# ============================================================================================\n# \ud83d\udce3 Events\n# ============================================================================================\n\nevent AuctionBid:\n    auction_id: indexed(uint256)\n    bidder: indexed(address)\n    caller: indexed(address)\n    value: uint256\n    extended: bool\n\n\nevent AuctionExtended:\n    auction_id: indexed(uint256)\n    end_time: uint256\n\n\nevent AuctionCreated:\n    auction_id: indexed(uint256)\n    start_time: uint256\n    end_time: uint256\n    ipfs_hash: String[46]\n\n\nevent AuctionSettled:\n    auction_id: indexed(uint256)\n    winner: address\n    amount: uint256\n\n\nevent AuctionNullified:\n    auction_id: indexed(uint256)\n\n\nevent Withdraw:\n    auction_id: indexed(uint256)\n    on_behalf_of: indexed(address)\n    caller: indexed(address)\n    amount: uint256\n\n\nevent ApprovedCallerSet:\n    account: address\n    caller: address\n    status: ApprovalStatus\n\n\nevent FeeReceiverUpdated:\n    fee_receiver: address\n\n\nevent FeePercentUpdated:\n    fee_percent: uint256\n\n\nevent DirectorySet:\n    directory_address: address\n\n\n# ============================================================================================\n# \ud83d\udcdc Constants\n# ============================================================================================\n\nMAX_WITHDRAWALS: constant(uint256) = 100\nMAX_AUCTIONS: constant(uint256) = 10000\nMAX_FEE_PERCENT: constant(uint256) = 100 * 10**8  # 100%\nPERCENT_PRECISION: constant(uint256) = 100 * 10**8\n\n\n# ============================================================================================\n# \ud83d\udcbe Storage\n# ============================================================================================\n\n# Auction\ndefault_time_buffer: public(uint256)\ndefault_reserve_price: public(uint256)\ndefault_min_bid_increment_percentage: public(uint256)\ndefault_duration: public(uint256)\n\n# Auction metadata: auction_id -> user -> ipfs\n# Can append ad text or other data via IPFS\nauction_metadata: public(HashMap[uint256, HashMap[address, String[46]]])\n\n# Auction pending returns due to users: auction_id -> user -> returns\nauction_pending_returns: public(HashMap[uint256, HashMap[address, uint256]])\nauction_list: public(HashMap[uint256, Auction])\nauction_id: public(uint256)\n\n# User settings: user -> caller -> status\napproved_caller: public(HashMap[address, HashMap[address, ApprovalStatus]])\n\n# Tokens\npayment_token: public(IERC20)\nauthorized_directory: public(AuctionDirectory)\n\n# Fee configuration\nfee_receiver: public(address)\nfee_percent: public(uint256)\n\n\n# ============================================================================================\n# \ud83d\udea7 Constructor\n# ============================================================================================\n\n@deploy\ndef __init__(\n    payment_token: address,\n    fee_receiver: address,\n):\n    assert payment_token != empty(address), \"!payment_token\"\n    assert fee_receiver != empty(address), \"!fee_receiver\"\n\n    ownable.__init__()\n    pausable.__init__()\n\n    # Set Payment Token and Default Parameters\n    self.payment_token = IERC20(payment_token)\n    self.fee_receiver = fee_receiver\n    self.fee_percent = 5 * 10**8  # 5%\n\n    # Duration 1 hour\n    self.default_duration = 3600\n    # Time buffer 5 minutes\n    self.default_time_buffer = 300\n    # Reserve price of 0.2 SQUID\n    self.default_reserve_price = 10**18 // 5\n    # Bid must be 2% higher\n    self.default_min_bid_increment_percentage = 2 * 10**8  # 2%\n\n\n# ============================================================================================\n# \ud83d\udc40 View functions\n# ============================================================================================\n\n@external\n@view\ndef current_auctions() -> DynArray[uint256, MAX_AUCTIONS]:\n    \"\"\"\n    @notice Get list of all currently active auction IDs\n    @dev Active means between start and end time, and not settled\n         Limited by MAX_AUCTIONS constant\n    @return Array of active auction IDs\n    \"\"\"\n    active_auctions: DynArray[uint256, MAX_AUCTIONS] = []\n\n    for i: uint256 in range(MAX_AUCTIONS):\n        if i + 1 > self.auction_id:\n            break\n\n        if self._is_auction_live(i + 1):\n            active_auctions.append(i + 1)\n    return active_auctions\n\n\n@external\n@view\ndef is_auction_live(auction_id: uint256) -> bool:\n    \"\"\"\n    @notice Check if an auction is currently active\n    @dev An auction is live if:\n         - Current time is between start and end time\n         - Auction is not settled\n         Note: Returns true even if contract is paused\n    @param auction_id The auction to check\n    @return True if auction is live, false otherwise\n    \"\"\"\n    return self._is_auction_live(auction_id)\n\n\n@external\n@view\ndef auction_remaining_time(auction_id: uint256) -> uint256:\n    \"\"\"\n    @notice Get remaining time for an auction in seconds\n    @dev Returns 0 if auction has ended\n    @param auction_id The auction to check\n    @return Seconds remaining until auction ends\n    \"\"\"\n    end_time: uint256 = self.auction_list[auction_id].end_time\n    remaining_time: uint256 = 0\n    if end_time > block.timestamp:\n        remaining_time = end_time - block.timestamp\n    return remaining_time\n\n\n@external\n@view\ndef auction_bid_by_user(auction_id: uint256, user: address) -> uint256:\n    \"\"\"\n    @notice Get total amount bid by user on specific auction\n    @dev Includes both current winning bid and any pending returns\n    @param auction_id Auction to check\n    @param user Address to check bids for\n    @return Total amount user has bid on this auction\n    \"\"\"\n    assert self.auction_list[auction_id].start_time != 0, \"!auction\"\n\n    return self._auction_bid_by_user(auction_id, user)\n\n\n@external\n@view\ndef minimum_total_bid(auction_id: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate minimum valid bid amount for an auction\n    @dev Returns reserve price if no bids yet\n         Otherwise current bid plus increment percentage\n    @param auction_id Auction to check\n    @return Minimum valid bid amount in payment tokens\n    \"\"\"\n    return self._minimum_total_bid(auction_id)\n\n\n@external\n@view\ndef minimum_additional_bid_for_user(\n    auction_id: uint256, user: address\n) -> uint256:\n    \"\"\"\n    @notice Returns the minimum additional amount a user must add to become top bidder for an auction\n    @param auction_id Auction to check\n    @return Required amount to bid in the payment token\n    \"\"\"\n    return self._minimum_additional_bid(auction_id, user)\n\n\n@external\n@view\ndef pending_returns(user: address) -> uint256:\n    \"\"\"\n    @notice Get total pending returns for a user across all auctions\n    @param user The address to check pending returns for\n    @return Total pending returns amount\n    \"\"\"\n    total_pending: uint256 = 0\n    for i: uint256 in range(MAX_AUCTIONS):\n        auction_id: uint256 = i + 1\n        if auction_id > self.auction_id:\n            break\n        total_pending += self.auction_pending_returns[auction_id][user]\n    return total_pending\n\n\n# ============================================================================================\n# \u270d\ufe0f Write functions\n# ============================================================================================\n\n\n@external\n@nonreentrant\ndef settle_auction(auction_id: uint256):\n    \"\"\"\n    @notice Finalizes an auction after end time, distributing proceeds\n    @dev Can only settle after auction end time\n         Distributes fees and proceeds\n         Mints NFT to winner if directory configured\n    @param auction_id ID of the auction to settle\n    @custom:security Cannot settle an auction more than once\n                     Must be past auction end time\n    \"\"\"\n    pausable._check_unpaused()\n    self._settle_auction(auction_id)\n\n\n@external\n@nonreentrant\ndef create_bid(\n    auction_id: uint256,\n    bid_amount: uint256,\n    ipfs_hash: String[46] = \"\",\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Create a bid using the contract's payment token\n    @dev Collects payment first, then updates auction state\n         Automatically extends auction if bid near end time\n         Previous bidder's amount moved to pending returns\n    @param auction_id ID of auction to bid on\n    @param bid_amount Total bid amount (must include any previous bids/returns)\n    @param ipfs_hash Optional IPFS hash for bid metadata\n    @param on_behalf_of Address to place bid for (defaults to caller)\n    @custom:security Requires caller to have bid permission for on_behalf_of\n                     Bid must meet reserve and increment requirements\n    \"\"\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.BidOnly)\n\n    payment_amount: uint256 = self._collect_payment(\n        auction_id, bid_amount, on_behalf_of\n    )\n    self._register_bid(auction_id, payment_amount, on_behalf_of)\n\n    # User may be requested to register data with their bid\n    if ipfs_hash != \"\":\n        self.auction_metadata[auction_id][on_behalf_of] = ipfs_hash\n\n\n@external\n@nonreentrant\ndef update_bid_metadata(\n    auction_id: uint256,\n    ipfs_hash: String[46],\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Update IPFS metadata associated with a user's bid\n    @dev Allows adding or updating metadata for any bid by user\n         Does not affect bid status or amount\n    @param auction_id The auction to update metadata for\n    @param ipfs_hash New IPFS hash to associate with bid\n    @param on_behalf_of Address to update metadata for (defaults to caller)\n    @custom:security Requires bid permission for on_behalf_of\n    \"\"\"\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.BidOnly)\n    self.auction_metadata[auction_id][on_behalf_of] = ipfs_hash\n\n\n@external\n@nonreentrant\ndef withdraw(\n    auction_id: uint256, on_behalf_of: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Withdraw pending returns from previous outbid\n    @dev Only available after auction is settled\n         Clears pending returns for auction/user combination\n    @param auction_id Auction to withdraw from\n    @param on_behalf_of Address to withdraw for (defaults to caller)\n    @return Amount of tokens withdrawn\n    @custom:security Requires withdraw permission for on_behalf_of\n                     Only withdraws if auction is settled\n    \"\"\"\n    pausable._check_unpaused()\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.WithdrawOnly)\n    assert self._is_auction_live(auction_id) == False, \"!inactive\"\n    assert self._is_auction_settled(auction_id), \"!settled\"\n\n    pending: uint256 = self.auction_pending_returns[auction_id][on_behalf_of]\n    assert pending > 0, \"!pending\"\n\n    self.auction_pending_returns[auction_id][on_behalf_of] = 0\n    assert extcall self.payment_token.transfer(\n        on_behalf_of, pending, default_return_value=True\n    ), \"!transfer\"\n    log Withdraw(auction_id, on_behalf_of, msg.sender, pending)\n    return pending\n\n\n@external\n@nonreentrant\ndef withdraw_multiple(\n    auction_ids: DynArray[uint256, MAX_WITHDRAWALS],\n    on_behalf_of: address = msg.sender,\n):\n    \"\"\"\n    @notice Batch withdraw pending returns from multiple auctions\n    @dev Only withdraws from settled auctions\n         Skips live auctions and non-settled auctions\n    @param auction_ids Array of auction IDs to withdraw from\n    @param on_behalf_of Address to withdraw for (defaults to caller)\n    @custom:security Requires withdraw permission for on_behalf_of\n                     Only processes settled auctions\n                     Limited to MAX_WITHDRAWALS auctions\n    \"\"\"\n    pausable._check_unpaused()\n    self._check_caller(on_behalf_of, msg.sender, ApprovalStatus.WithdrawOnly)\n    total_pending: uint256 = 0\n    settled_auction_exists: bool = False\n    for auction_id: uint256 in auction_ids:\n        if self._is_auction_live(auction_id):\n            continue\n\n        if not self._is_auction_settled(auction_id):\n            continue\n\n        settled_auction_exists = True\n        pending: uint256 = self.auction_pending_returns[auction_id][\n            on_behalf_of\n        ]\n        if pending > 0:\n            total_pending += pending\n            self.auction_pending_returns[auction_id][on_behalf_of] = 0\n            log Withdraw(auction_id, on_behalf_of, msg.sender, pending)\n    assert settled_auction_exists, \"!settled\"\n    assert total_pending > 0, \"!pending\"\n    assert extcall self.payment_token.transfer(\n        on_behalf_of, total_pending, default_return_value=True\n    ), \"!transfer\"\n\n\n@external\n@nonreentrant\ndef withdraw_stale(addresses: DynArray[address, MAX_WITHDRAWALS]):\n    \"\"\"\n    @notice Admin function to process unclaimed returns with fee penalty\n    @dev Only callable by owner\n         Processes all pending returns for each address\n         Takes fee percentage from unclaimed amounts\n    @param addresses Array of addresses to process\n    @custom:security Only callable by owner\n                     Limited to MAX_WITHDRAWALS addresses\n                     Cannot process after contract is deprecated\n    \"\"\"\n    ownable._check_owner()\n    pausable._check_unpaused()\n\n    total_fee: uint256 = 0\n    for _address: address in addresses:\n        # Sum up pending returns across all auctions\n        pending_amount: uint256 = 0\n        for i: uint256 in range(MAX_AUCTIONS):\n            auction_id: uint256 = i + 1\n            if auction_id > self.auction_id:\n                break\n\n            auction_pending: uint256 = self.auction_pending_returns[auction_id][\n                _address\n            ]\n            if auction_pending > 0:\n                pending_amount += auction_pending\n                self.auction_pending_returns[auction_id][_address] = 0\n        if pending_amount == 0:\n            continue\n\n        fee: uint256 = pending_amount * self.fee_percent // PERCENT_PRECISION\n        withdrawer_return: uint256 = pending_amount - fee\n        assert extcall self.payment_token.transfer(\n            _address, withdrawer_return\n        ), \"Token transfer failed\"\n        total_fee += fee\n\n    if total_fee > 0:\n        assert extcall self.payment_token.transfer(\n            self.fee_receiver, total_fee\n        ), \"Fee transfer failed\"\n\n\n@external\ndef set_approved_caller(caller: address, status: ApprovalStatus):\n    \"\"\"\n    @notice Configure delegation permissions for a specific caller\n    @dev Allows user to set granular permissions for another address\n    @param caller Address being granted or restricted permissions\n    @param status Approval level for the caller:\n                  - Nothing: No permissions\n                  - BidOnly: Can place bids on behalf of user\n                  - WithdrawOnly: Can withdraw funds on behalf of user\n                  - BidAndWithdraw: Full bidding and withdrawal permissions\n    \"\"\"\n    self.approved_caller[msg.sender][caller] = status\n    log ApprovedCallerSet(msg.sender, caller, status)\n\n\n# ============================================================================================\n# \ud83d\udc51 Owner functions\n# ============================================================================================\n\n@external\n@nonreentrant\ndef create_new_auction(ipfs_hash: String[46] = \"\") -> uint256:\n    \"\"\"\n    @dev Create a new auction with default parameters\n    @param ipfs_hash The IPFS hash of the auction metadata\n    @return New auction id\n    \"\"\"\n    pausable._check_unpaused()\n    ownable._check_owner()\n    return self._create_auction(ipfs_hash, self._default_auction_params())\n\n\n@external\n@nonreentrant\ndef create_custom_auction(\n    time_buffer: uint256,\n    reserve_price: uint256,\n    min_bid_increment_percentage: uint256,\n    duration: uint256,\n    ipfs_hash: String[46] = \"\",\n) -> uint256:\n    \"\"\"\n    @dev Create a new auction with custom parameters instead of defaults\n    @param ipfs_hash The IPFS hash of the auction metadata\n    @return New auction id\n    \"\"\"\n    pausable._check_unpaused()\n    ownable._check_owner()\n    return self._create_auction(\n        ipfs_hash,\n        AuctionParams(\n            time_buffer=time_buffer,\n            reserve_price=reserve_price,\n            min_bid_increment_percentage=min_bid_increment_percentage,\n            duration=duration,\n        ),\n    )\n\n\n@external\ndef nullify_auction(auction_id: uint256):\n    \"\"\"\n    @notice Emergency function to cancel an auction\n    @dev Only callable by owner\n         Moves current winning bid to pending returns\n         Marks auction as settled to prevent further bids\n    @param auction_id ID of auction to nullify\n    @custom:security Cannot nullify already settled auction\n                     Current high bid protected via pending returns\n    \"\"\"\n    ownable._check_owner()\n    assert self._is_auction_settled(auction_id) == False, \"settled\"\n\n    _auction: Auction = self.auction_list[auction_id]\n    _winner: address = _auction.bidder\n    _win_bid: uint256 = _auction.amount\n\n    self.auction_list[auction_id] = Auction(\n        auction_id=_auction.auction_id,\n        amount=0,\n        start_time=_auction.start_time,\n        end_time=block.timestamp - 1,\n        bidder=empty(address),\n        settled=True,\n        ipfs_hash=_auction.ipfs_hash,\n        params=_auction.params,\n    )\n\n    self.auction_pending_returns[auction_id][_winner] = _win_bid\n\n    log AuctionNullified(auction_id)\n\n\n@external\ndef set_fee_receiver(_fee_receiver: address):\n    \"\"\"\n    @notice Update address receiving auction fees\n    @dev Only callable by owner\n    @param _fee_receiver New fee receiving address\n    @custom:security Cannot set to zero address\n    \"\"\"\n    ownable._check_owner()\n    assert _fee_receiver != empty(address), \"!fee_receiver\"\n    self.fee_receiver = _fee_receiver\n    log FeeReceiverUpdated(_fee_receiver)\n\n\n@external\ndef set_fee_percent(_fee: uint256):\n    \"\"\"\n    @notice Update fee percentage taken from auction proceeds\n    @dev Only callable by owner\n         Fee is expressed in basis points with 8 decimal precision\n    @param _fee New fee percentage (max 100 * 10**8)\n    @custom:security Cannot exceed MAX_FEE_PERCENT\n    \"\"\"\n    ownable._check_owner()\n    assert _fee <= MAX_FEE_PERCENT, \"!fee\"\n    self.fee_percent = _fee\n    log FeePercentUpdated(_fee)\n\n\n@external\ndef set_approved_directory(directory_address: address):\n    \"\"\"\n    @notice Set authorized directory contract address\n    @dev Only callable by owner\n         Directory contract gets special permissions for bidding\n    @param directory_address Address of directory contract\n    @custom:security Directory can bypass normal approval checks\n                     Only one directory can be authorized at a time\n    \"\"\"\n    ownable._check_owner()\n    self.authorized_directory = AuctionDirectory(directory_address)\n    log DirectorySet(directory_address)\n\n\n@external\ndef recover_erc20(token_addr: address, amount: uint256):\n    \"\"\"\n    @notice Recover ERC20 tokens accidentally sent to contract\n    @dev Only callable by owner. If recovering payment token, ensures auction funds are protected\n    @param token_addr The token contract address\n    @param amount Amount of tokens to recover\n    \"\"\"\n    ownable._check_owner()\n    token: IERC20 = IERC20(token_addr)\n\n    # Special handling for payment token to protect auction funds\n    if token.address == self.payment_token.address:\n        required_balance: uint256 = 0\n\n        # Calculate total required balance for all auctions\n        for i: uint256 in range(MAX_AUCTIONS):\n            auction_id: uint256 = i + 1\n            if auction_id > self.auction_id:\n                break\n\n            auction: Auction = self.auction_list[auction_id]\n            # Include active bid amount if auction not settled\n            if not auction.settled:\n                required_balance += auction.amount\n        current_balance: uint256 = staticcall token.balanceOf(self)\n        assert (\n            current_balance - amount >= required_balance\n        ), \"cannot recover auction funds\"\n\n    assert extcall token.transfer(ownable.owner, amount), \"transfer failed\"\n\n\n# ============================================================================================\n# \ud83c\udfe0 Internal functions\n# ============================================================================================\n\n@internal\ndef _default_auction_params() -> AuctionParams:\n    return AuctionParams(\n        time_buffer=self.default_time_buffer,\n        reserve_price=self.default_reserve_price,\n        min_bid_increment_percentage=self.default_min_bid_increment_percentage,\n        duration=self.default_duration,\n    )\n\n\n@internal\ndef _create_auction(ipfs_hash: String[46], params: AuctionParams) -> uint256:\n    pausable._check_unpaused()\n    _start_time: uint256 = block.timestamp\n    _end_time: uint256 = _start_time + params.duration\n    _auction_id: uint256 = self.auction_id + 1\n\n    self.auction_id = _auction_id\n    self.auction_list[_auction_id] = Auction(\n        auction_id=_auction_id,\n        amount=0,\n        start_time=_start_time,\n        end_time=_end_time,\n        bidder=empty(address),\n        settled=False,\n        ipfs_hash=ipfs_hash,\n        params=params,\n    )\n\n    log AuctionCreated(_auction_id, _start_time, _end_time, ipfs_hash)\n    return _auction_id\n\n\n@internal\ndef _settle_auction(auction_id: uint256):\n    _auction: Auction = self.auction_list[auction_id]\n    assert _auction.start_time != 0, \"!auction\"\n    assert self._is_auction_settled(auction_id) == False, \"settled\"\n    assert block.timestamp > _auction.end_time, \"!completed\"\n\n    self.auction_list[auction_id] = Auction(\n        auction_id=_auction.auction_id,\n        amount=_auction.amount,\n        start_time=_auction.start_time,\n        end_time=_auction.end_time,\n        bidder=_auction.bidder,\n        settled=True,\n        ipfs_hash=_auction.ipfs_hash,\n        params=_auction.params,\n    )\n\n    if _auction.amount > 0:\n        fee_amount: uint256 = (\n            _auction.amount * self.fee_percent // PERCENT_PRECISION\n        )\n        remaining_amount: uint256 = _auction.amount - fee_amount\n\n        if fee_amount > 0:\n            assert extcall self.payment_token.transfer(\n                self.fee_receiver, fee_amount, default_return_value=True\n            ), \"!fee transfer\"\n\n        assert extcall self.payment_token.transfer(\n            ownable.owner, remaining_amount, default_return_value=True\n        ), \"!owner transfer\"\n\n    if self.authorized_directory.address != empty(address):\n        extcall self.authorized_directory.mint_nft(_auction.bidder, auction_id)\n\n    log AuctionSettled(_auction.auction_id, _auction.bidder, _auction.amount)\n\n\n@internal\ndef _collect_payment(\n    auction_id: uint256,\n    total_bid: uint256,\n    bidder: address,\n) -> uint256:\n    \"\"\"\n    @dev Collect payment either in payment or alternate token\n    @return Final amount of payment token collected (including any pending returns used)\n    \"\"\"\n    assert total_bid > 0, \"!bid_amount\"\n\n    # Get pending returns without double counting\n    pending_returns: uint256 = self.auction_pending_returns[auction_id][bidder]\n    auction: Auction = self.auction_list[auction_id]\n\n    # Get winning bid amount if any\n    winning_amount: uint256 = 0\n    if auction.bidder == bidder:\n        winning_amount = auction.amount\n\n    available_tokens: uint256 = pending_returns + winning_amount\n\n    # How many new tokens needed\n    tokens_needed: uint256 = total_bid\n    if available_tokens >= tokens_needed:\n        self.auction_pending_returns[auction_id][bidder] = (\n            available_tokens - tokens_needed\n        )\n        tokens_needed = 0\n    else:\n        self.auction_pending_returns[auction_id][bidder] = 0\n        tokens_needed -= available_tokens\n\n    if tokens_needed > 0:\n        token_source: address = bidder\n        if msg.sender == self.authorized_directory.address:\n            token_source = self.authorized_directory.address\n        assert extcall self.payment_token.transferFrom(\n            token_source, self, tokens_needed, default_return_value=True\n        ), \"!transfer\"\n\n    return total_bid\n\n\n@internal\ndef _register_bid(auction_id: uint256, total_bid: uint256, bidder: address):\n    pausable._check_unpaused()\n\n    _auction: Auction = self.auction_list[auction_id]\n    _time_buffer: uint256 = _auction.params.time_buffer\n    _reserve_price: uint256 = _auction.params.reserve_price\n\n    assert _auction.auction_id == auction_id, \"!auctionId\"\n    assert block.timestamp < _auction.end_time, \"expired\"\n    assert total_bid >= _reserve_price, \"!reservePrice\"\n    assert total_bid >= self._minimum_total_bid(auction_id), \"!increment\"\n\n    # Store old bid and cancel it out\n    last_bidder: address = _auction.bidder\n    last_amount: uint256 = _auction.amount\n    self.auction_pending_returns[auction_id][bidder] = 0\n\n    # If the bidder has changed, credit the former bidder\n    if last_bidder != empty(address) and last_bidder != bidder:\n        self.auction_pending_returns[auction_id][last_bidder] += _auction.amount\n\n    _end_time: uint256 = _auction.end_time\n    _extended: bool = _auction.end_time - block.timestamp < _time_buffer\n    if _extended:\n        _end_time = block.timestamp + _time_buffer\n\n    self.auction_list[auction_id] = Auction(\n        auction_id=_auction.auction_id,\n        amount=total_bid,\n        start_time=_auction.start_time,\n        end_time=_end_time,\n        bidder=bidder,\n        settled=_auction.settled,\n        ipfs_hash=_auction.ipfs_hash,\n        params=_auction.params,\n    )\n\n    log AuctionBid(\n        _auction.auction_id, bidder, msg.sender, total_bid, _extended\n    )\n    if _extended:\n        log AuctionExtended(_auction.auction_id, _auction.end_time)\n\n\n@internal\n@view\ndef _minimum_total_bid(auction_id: uint256) -> uint256:\n    _auction: Auction = self.auction_list[auction_id]\n    assert _auction.start_time != 0, \"!auctionId\"\n    assert not self._is_auction_settled(auction_id), \"settled\"\n\n    if _auction.amount == 0:\n        return _auction.params.reserve_price\n\n    _min_pct: uint256 = _auction.params.min_bid_increment_percentage\n    return _auction.amount + ((_auction.amount * _min_pct) // PERCENT_PRECISION)\n\n\n@internal\n@view\ndef _minimum_additional_bid(\n    auction_id: uint256, bidder: address = empty(address)\n) -> uint256:\n    _total_min: uint256 = self._minimum_total_bid(auction_id)\n    if bidder == empty(address):\n        return _total_min\n\n    pending: uint256 = self.auction_pending_returns[auction_id][bidder]\n    if pending >= _total_min:\n        return 0\n    return _total_min - pending\n\n\n@internal\n@view\ndef _check_caller(\n    _account: address, _caller: address, _req_status: ApprovalStatus\n):\n    # Directory contract assumes onus of confirming status\n    if _account != _caller and msg.sender != self.authorized_directory.address:\n        _status: ApprovalStatus = self.approved_caller[_account][_caller]\n        if _status == ApprovalStatus.BidAndWithdraw:\n            return\n        assert (_status == _req_status), \"!caller\"\n\n\n@internal\n@view\ndef _is_auction_settled(auction_id: uint256) -> bool:\n    return self.auction_list[auction_id].settled\n\n\n@internal\n@view\ndef _is_auction_live(auction_id: uint256) -> bool:\n    \"\"\"\n    @dev Note an auction will be considered live even if the contract is paused.\n    \"\"\"\n    _is_live: bool = False\n    _auction: Auction = self.auction_list[auction_id]\n    if (\n        _auction.start_time <= block.timestamp\n        and block.timestamp <= _auction.end_time\n        and not _auction.settled\n    ):\n        _is_live = True\n\n    return _is_live\n\n\n@internal\n@view\ndef _auction_bid_by_user(auction_id: uint256, user: address) -> uint256:\n    auction: Auction = self.auction_list[auction_id]\n    total_bid: uint256 = 0\n\n    # Add pending returns from previous outbid amounts\n    total_bid += self.auction_pending_returns[auction_id][user]\n\n    # Add current winning bid amount if they are the current winner\n    if auction.bidder == user:\n        total_bid += auction.amount\n\n    return total_bid\n",
      "sha256sum": "ab08e933be880ef5a4032242f0c264d52cb27f7c75e47de37e09980e019edc23"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/AuctionBlock.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "7f732bdf79b6d76a70fc1c11afc3c1914cf2e795b4fa81cd2af0f66e572bb5d2"
}